---
title: "Exploring Watina"
date: '`r paste("Version",lubridate::now())`'
output:
  html_notebook:
    number_sections: yes
    code_folding: show
    includes:
      in_header: ../header.html
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: no
---

```{r setup, message=FALSE, echo=FALSE}
options(stringsAsFactors = FALSE)
# library(sp)
# library(sf)
# library(raster)
library(tidyverse)
library(stringr)
# library(n2khab)
# library(plotly)
# library(rasterVis)
# library(stars)
library(DBI)
source("../private_code.R") # just loads connection string for Watina DB
library(dbplyr)
library(dbplot)
library(knitr)
opts_chunk$set(
  echo = TRUE,
  dpi = 300
)
```

# Querying the Watina groundwater database and exploring tables

The below explorations are based on code of Ivy Jansen, but use the `DBI` library instead of `RODBC` (`DBI` is standard in RStudio).


```{r}
con <- inborutils::connect_inbo_dbase("W0002_00_Watina")
```


```{r}
dbListTables(con) %>% sort %>%  View("tables")
```

```{r}
dbListTables(con) %>% 
  sort %>% 
  enframe() %>% 
  
```


```{r}
dbGetQuery(con, "SELECT * FROM ext.vwDocumentatie") %>% 
  arrange(tablename) %>% 
  View("docu")
```

The above was the DWH (datawarehouse).
What is in the database itself?

```{r}
con2 <- inborutils::connect_inbo_dbase("D0025_00_Watina")
```

Aha.

## Locations and filters

Listing relevant tables and showing first records:

```{r}
locations <-  tbl(con, "vwDimMeetpunt")
locations %>% glimpse
```

Variables of interest: `MeetpuntWID`, `MeetpuntCode`, `MeetpuntStatusCode`, `MeetpuntTypeCode`, `MeetpuntXCoordinaat`, `MeetpuntYCoordinaat`.


```{r}
# dbplot library provides a few basic graph functions for which the 
# calculations are executed inside the database, and a ggplot object is returned.
locations %>% 
    dbplot_raster(MeetpuntXCoordinaat, 
                  MeetpuntYCoordinaat, resolution = 300) +
    coord_fixed()
```


```{r}
dbGetQuery(con, 'SELECT TOP(6) * FROM DimMeetpunt')
```

```{r}
locations %>% 
  count(MeetpuntTypeCode, MeetpuntType)
```

```{r}
locations %>% 
  distinct(MeetpuntTypeCode) %>% 
  pull(MeetpuntTypeCode) %>% 
  dput
```

```{r}
locations %>% 
  count(MeetpuntStatusCode, MeetpuntStatus)
```

```{r}
locations %>% 
  distinct(MeetpuntStatusCode) %>% 
  pull(MeetpuntStatusCode) %>% 
  dput
```

```{r}
areas <- tbl(con, "vwDimGebied")
areas %>% glimpse()
```

```{r}
locations %>% 
  inner_join(areas) %>% 
  mutate(area_name2 = str_sub(MeetpuntCode, end = 3)) %>% 
  count(area_name2, GebiedCode) %>% 
  filter(area_name2 != GebiedCode) %>% 
  collect %>% 
  nrow
```



```{r}
gwfilters <- tbl(con, "vwDimPeilpunt")
```


```{r}
gwfilters %>% glimpse
```

Variables of interest: `MeetpuntWID`, `PeilpuntCode`, `PeilpuntStatusCode`, `PeilbuisLengte`, `ReferentieNiveauMaaiveld`.

Note the difference between:

```{r}
gwfilters %>% 
  count
```

and:

```{r}
gwfilters %>% 
  distinct(PeilpuntCode) %>%
  count
```

```{r}
gwfilters %>% 
  distinct(PeilpuntCode,
           MeetpuntWID,
           PeilpuntStatusCode,
           PeilbuisLengte,
           ReferentieNiveauMaaiveld) %>%
  count
```

So the needed information is duplicated in the table.

Example:

```{r}
gwfilters %>% 
  filter(PeilpuntCode == "AABP001X") %>% 
  collect
```

Another way of obtaining this seems to be:

```{r}
gwfilters %>% 
  filter(PeilpuntOpenbaarheidTypeCode == "PLME", PeilpuntOpenbaarheidCode == "UNKWN") %>%
  count
```


Info on an odd record (this seems a mistake):

```{r paged.print = FALSE, message=FALSE}
gwfilters %>% 
  distinct(PeilpuntCode,
           MeetpuntWID,
           PeilpuntStatusCode,
           PeilbuisLengte,
           ReferentieNiveauMaaiveld) %>%
  count(PeilpuntCode) %>% 
  filter(n > 1) %>% 
  inner_join(gwfilters)
```

Different available combinations:

```{r}
gwfilters %>% 
  count(PeilpuntOpenbaarheidTypeCode,
        PeilpuntOpenbaarheidCode,
        PeilpuntOpenbaarheidNaam) %>% 
  collect %>% 
  arrange(PeilpuntOpenbaarheidTypeCode)
```

Occurring combinations within the same PeilpuntOpenbaarheidTypeCode x PeilpuntCode:

```{r paged.print = FALSE}
gwfilters %>% 
  group_by(PeilpuntOpenbaarheidTypeCode, PeilpuntCode) %>% 
  arrange(PeilpuntOpenbaarheidCode) %>% 
  collect %>%
  summarise(comb = str_flatten(PeilpuntOpenbaarheidCode, collapse = "-")) %>% 
  count(comb)
```

We should filter PeilpuntStatusCode for values in `c("VLD", "ENT", "CLD")`.

```{r}
gwfilters %>% 
  count(PeilpuntStatusCode, PeilpuntStatusNaam)
```

The table `vwDimPeilpunt` will be needed to select the shallow groundwater filters (i.e. with filter base < 3 m below soil surface), and to select the shallowest filter from (remaining) filters duplets.

Let's explore that a little more:

```{r}
gwfilters <- 
  gwfilters %>% 
  filter(PeilpuntStatusCode %in% c("VLD","ENT","CLD")) %>% 
  distinct(PeilpuntCode,
           MeetpuntWID,
           PeilpuntStatusCode,
           PeilbuisLengte,
           ReferentieNiveauMaaiveld)
```


```{r}
gwfilters %>% 
  dbplot_histogram(ReferentieNiveauMaaiveld)
```

```{r}
gwfilters %>% 
  filter(is.na(ReferentieNiveauMaaiveld)) %>% 
  collect %>% 
  nrow
```

```{r}
gwfilters %>% 
  select(1) %>% 
  collect %>% 
  nrow
```


```{r}
gwfilters %>% 
    mutate(filterbase = -(PeilbuisLengte - ReferentieNiveauMaaiveld)) %>% 
    ggplot(aes(x = filterbase)) + 
    geom_histogram(colour = "grey90") +
    scale_y_log10() +
    xlab("filterbase (m below soil surface)")
```

```{r}
gwfilters %>% 
    collect %>%
    mutate(filterbase = -(PeilbuisLengte - ReferentieNiveauMaaiveld),
           shallow = filterbase > -3) %>% 
    filter(filterbase > -10) %>% 
    ggplot(aes(x = filterbase, fill = shallow)) +
    geom_histogram(binwidth = 0.5, colour = "grey90") + 
    # scale_y_log10() +
    xlab("filterbase (m below soil surface)")
```

```{r}
gwfilters %>% 
    mutate(filterbase = -(PeilbuisLengte - ReferentieNiveauMaaiveld)) %>% 
    filter(filterbase == -3) %>% 
    select(PeilpuntCode) %>% 
    collect %>% 
    nrow
```

Just including the filterdepths of exactly 3 meters deep would however add 129 filters, so let's include that one as well (it probably has to do with rounding effects):

```{r}
gwfilters %>% 
    collect %>%
    mutate(filterbase = -(PeilbuisLengte - ReferentieNiveauMaaiveld),
           shallow = filterbase >= -3) %>% 
    filter(filterbase > -10) %>% 
    ggplot(aes(x = filterbase, fill = shallow)) +
    geom_histogram(binwidth = 0.5, colour = "grey90") + 
    # scale_y_log10() +
    xlab("filterbase (m below soil surface)")
```

```{r}
gwfilters %>% 
    mutate(filterbase = -(PeilbuisLengte - ReferentieNiveauMaaiveld)) %>% 
    filter(filterbase >= -3) %>% 
    select(PeilpuntCode) %>% 
    collect %>% 
    nrow
```


## Groundwater levels: XG3

```{r}
# "SELECT * FROM ssrs_Precalc"
# the following works:
XG3 <- tbl(con, "ssrs_Precalc")
XG3 %>% glimpse()
```

Variables of interest for MNE: `HydroJaar`, `MeetpuntWID`, `GHG_2`, `GLG_2`, `GVG_2`, `MetingTypeWID`.
Optionally (with a switch?) the `_1` versions of the XG3 variables.
`_1`-variables are the absolute groundwater levels, `_2`-variables are the groundwater levels relative to soil surface.

Nr of rows in this table:

```{r}
XG3 %>% collect %>% nrow
```

Positive values will need to be set to zero:

```{r}
XG3 %>% 
    filter(GHG_2 > -2,
           GHG_2 < 1.5) %>% 
    dbplot_histogram(GHG_2)
```


```{r echo=TRUE}
tbl(con, "DimMetingType")
```

Will this table be of use?
May be.
We could replace `MetingTypeWID` in the previous table by a factor `measurement_type`, using the codes from `MetingTypeWID` and translating these (within a function that has a `lang` argument) to a label variable with either Dutch or English (or ...) names by storing those in the `namelist` data source of the R package.


## Chemical data

```{r}
# "SELECT * FROM DimChemVar"
# the following works:
chemvars <- tbl(con, "DimChemVar")
chemvars %>% glimpse()
```

This table provides the chemical variable definitions.

```{r}
# "SELECT * FROM FactChemischeMeting"
# the following works:
chem_measurements <- tbl(con, "FactChemischeMeting")
chem_measurements %>% glimpse
```

This table provides the chemical measurements.
Essential variables are: `MeetpuntWID`, `DatumWID`, `ChemVarWID`, `Meetwaarde`, `MeetwaardeMEQ`, `IsBelowLOQ`.

`DatumWID` refers to the `DimTijd` table:

```{r}
dates <- tbl(con, "DimTijd")
dates %>% glimpse()
```


What about this one?

```{r}
chem_measurements2 <- tbl(con, "vwFactChemischeMeting")
chem_measurements2 %>% glimpse
```


Missing in both cases: electroneutrality (but see CÃ©cile's [remark](https://docs.google.com/a/inbo.be/document/d/1isa_9HYQcxo8OYi0fKYmLY42GGTNxpev6RgW05WNxE4/edit?disco=AAAACuSS6FU)).
Conclusion on this remark is that electroneutrality is most reliable in the DWH, see below table.

Electroneutrality is in the following table:

```{r}
elneutr <- tbl(con, "ssrs_StaalEN")
elneutr %>% 
  glimpse
```

Here we will need `StaalID` and `StaalEN`.

No `NA` values occur, this is because only samples with a value are present in this table:

```{r}
elneutr %>% 
  collect %>% 
  count(is.na(StaalEN))
```

Only part of the chemical samples has a value for `StaalEN`:

```{r message=FALSE}
chem_measurements %>% 
  distinct(StaalID, DatumWID) %>% 
  left_join(elneutr %>% select(StaalID, StaalEN)) %>% 
  collect %>% 
  group_by(is.na(StaalEN)) %>% 
  summarise(n = n(),
            mindate = min(DatumWID),
            maxdate = max(DatumWID))
```

This should be because for the majority of chemical samples, `StaalEN` could not be calculated because of missing ion concentration data.

Both tables with chemical measurements have the same number of records:

```{r}
chem_measurements %>% count
chem_measurements2 %>% count
```

Which status codes do occur?

```{r}
chem_measurements %>% 
  group_by(MetingStatusCode,
           MetingStatus) %>% 
  summarise(n = n(),
            mindate = min(DatumWID),
            maxdate = max(DatumWID))
```

After further enquiry, it appears that these codes originate from former workflows and should be neglected!

Which values occur for `IsBelowLOQ`?

```{r}
chem_measurements %>% 
  group_by(IsBelowLOQ) %>% 
  summarise(n = n(),
            mindate = min(DatumWID),
            maxdate = max(DatumWID))
```

The interpretation here is that:

- only for LIMS data this is (automatically) imported, i.e. for data since 2014.
This concerns the `TRUE` & `FALSE` values.
- The `NA` values after 2014 are from external sources.

No `NA` values occur for `Meetwaarde` when `IsBelowLOQ == "TRUE"`:

```{r}
chem_measurements %>% 
  filter(IsBelowLOQ == "TRUE") %>% 
  select(Meetwaarde) %>% 
  collect %>% 
  summary
```

This is because LOQ values were used and divided by 2, in those cases:

```{r}
```{r}
chem_measurements %>% 
  filter(IsBelowLOQ == "TRUE") %>% 
  inner_join(chemvars,
             by = "ChemVarWID") %>% 
  select(ChemVarCode, Meetwaarde) %>% 
  collect %>% 
  split(x = ., f = .$ChemVarCode) %>% 
  purrr::map(.x = ., .f = table)
```
```


Difference in the _presence_ of mass vs. meq data?

```{r}
chem_measurements %>% 
  mutate(isna = ifelse(is.na(Meetwaarde), 1, 0),
         isna_meq = ifelse(is.na(MeetwaardeMEQ), 1, 0)) %>% 
  summarise(na_count = sum(isna),
            non_na_count = sum(1 - isna),
            na_count_meq = sum(isna_meq),
            non_na_count_meq = sum(1 - isna_meq)
            )
```

No!

For which variables are these values equal?

```{r}
chem_measurements %>% 
  filter(Meetwaarde == MeetwaardeMEQ,
         IsBelowLOQ == "FALSE") %>% 
  count(ChemVarWID) %>% 
  inner_join(chemvars %>% select(ChemVarWID, ChemVarNaam, ChemVarEenheid),
             by = "ChemVarWID")
```

```{r}
chem_measurements %>% 
  filter(IsBelowLOQ == "FALSE") %>% 
  inner_join(chemvars %>% select(ChemVarWID, ChemVarNaam, ChemVarEenheid),
             by = "ChemVarWID") %>% 
  filter(ChemVarNaam %in% c("Al", "Mn", "Si")) %>% 
  count
```

So _all_ data of Al, Mn and Si show no difference between both columns.
It appears they wrongly have a `Coefficient` = 1 in `chemvars`.

Checking calculations where `Coefficient` > 1, this seems OK:

```{r}
chem_measurements %>% 
  filter(IsBelowLOQ == "FALSE") %>% 
  inner_join(chemvars %>% 
               select(ChemVarWID, ChemVarNaam, ChemVarEenheid, Coefficient) %>% 
               filter(Coefficient > 1),
             by = "ChemVarWID") %>% 
  mutate(test = Meetwaarde / Coefficient) %>% 
  select(ChemVarNaam, Meetwaarde, MeetwaardeMEQ, test, Coefficient)
```

```{r}
chem_measurements %>% 
  inner_join(chemvars %>% select(ChemVarWID, ChemVarNaam, ChemVarEenheid),
             by = "ChemVarWID") %>% 
  count(ChemVarNaam)
```


```{r}
dbDisconnect(con)
```


