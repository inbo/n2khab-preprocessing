---
title: "Inspecting an internal draft of the watersurfaces data source"
date: "`r paste('Version',lubridate::now())`"
output:
  html_document:
    df_print: paged
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: no
    number_sections: yes
    code_folding: show
    includes:
      in_header: ../header.html
---

```{r setup, message=FALSE, echo=FALSE}
library(sf)
library(dplyr)
library(tmap)
library(n2khab)
library(ggplot2)
library(knitr)
opts_chunk$set(
  echo = TRUE,
  dpi = 300
)
```

# Exploring an internal draft of the watersurfaces data source

Prior to publication, updates of the watersurfaces happen in a MS SQL Server database.

Here we do some checks from R in order to prevent possible problems in a released version of the data source.

Make the database connection and the query:

```{r dev-after-v1.2}
con <- inbodb::connect_inbo_dbase("G0102_00_AquaMorf")
query <- sql("SELECT P.CodePlas AS WVLC, 
                  plasnaamalt AS WTRLICHC,
                  NP_ID AS HYLAC,
                  plasnaam AS NAAM, 
                  P.gebied AS GEBIED,
                  P.watertype AS KRWTYPE,
                  P.watertypeAlt AS KRWTYPEA,
                  P.statuswatertype AS KRWTYPES,
                  P.DiepteKlasse AS DIEPKL, 
                  P.connectiviteit11 AS CONNECT, 
                  P.peilbeheer AS PEILBEHEER,
                  shape.STArea() AS OPPWVL,
                  shape.STLength() AS OMTWVL,
                  P.DiepteGem_m AS diepte_gem, 
                  P.DiepteMax_m AS diepte_max, 
                  P.gebiedalternatief AS gebied_alt,
                  connectiviteit AS connect_old,
                  P.jaaraanleg AS aanleg,
                  P.status AS status, 
                  shape.STAsBinary() AS geometry
          FROM AquaMorf.PLAS P
          WHERE GDB_TO_DATE >= '9999' AND status IS NULL")
# show all columns of the database table with:
# tbl(con, I("AquaMorf.PLAS")) |> glimpse()
```

Note that we map variable names of version 1.2 in capitals to database column names.
Some other available names have been kept lowercase.

Import the spatial layer:

```{r spatial-layer}
ws <- read_sf(con, query = query, crs = 31370) |> 
  mutate(across(where(is.character), factor))
glimpse(ws)
```

The number of rows is `r nrow(ws)`.

Sidenote: `read_sf()` downloads the data, but it is also possible to define a lazy object, execute database-level queries using dplyr verbs on this object (before collecting), and then convert to sf after collecting a filtered result.
Example below:

```{r paged.print=FALSE, collapse=TRUE}
ws_db <- tbl(con, query)
# without conversion to sf
ws_db |> 
  filter(row_number() <= 25) |> 
  select(WVLC, geometry) |> 
  collect()
# one can still convert the binary geometries to WKB; see
# https://hydroecology.net/reading-spatial-data-from-sql-server-without-sf/
ws_db |> 
  filter(row_number() <= 25) |> 
  select(WVLC, geometry) |> 
  collect() |> 
  mutate(geometry = wk::as_wkb(geometry))
# conversion to sf:
ws_db |> 
  filter(row_number() <= 25) |> 
  select(WVLC, geometry) |> 
  collect() |>
  st_as_sf(crs = 31370)
```

```{r}
DBI::dbDisconnect(con)
```


## Step-by-step exploration

### A summary of the spatial layer

```{r}
ws %>% 
  st_drop_geometry %>% 
  summary
```

Compared to version 1.2:

- `FUNCTION` is absent from the query.
- `KRWTYPEA` is a new variable.
- `CONNECT` has new levels.
- Note: `HYLAC` is going to be removed in the official version.
- Several columns are available (lowercase names in the query) which haven't been part of the official version yet (except for `connect_old`, which was `CONNECT` in previous versions).

Let us look for a few typical errors more systematically.

### Are there `NA` values?

There are plenty of `NA`'s but only in fields where we expect them.

```{r}
sapply(ws, function(x) sum(is.na(x)))
```

`KRWTYPE` / `KRWTYPEA` / `KRWTYPES` consistency:

```{r}
ws |> 
  st_drop_geometry() |> 
  count(KRWTYPE, KRWTYPES) |> 
  print()
ws |> 
  st_drop_geometry() |> 
  filter(!is.na(KRWTYPEA), KRWTYPEA != "-") |> 
  count(KRWTYPE, KRWTYPEA) |> 
  print(n = Inf)
```

One record has `KRWTYPES` set to 'voorlopig':

```{r}
ws |> filter(KRWTYPES == "voorlopig") |> as.matrix() |> t()
```


### Are there `<Null>` values?

None:

```{r}
sapply(ws |> st_drop_geometry(), function(x) sum(as.character(x) == '<Null>', na.rm = TRUE))
```

### Are there `-` values?

Yes, in `KRWTYPEA`, but it's expected (see further):

```{r}
sapply(ws |> st_drop_geometry(), function(x) sum(as.character(x) == '-', na.rm = TRUE))
```

### Are there Zero (0) values?

None:

```{r}
sapply(ws |> st_drop_geometry(), function(x) sum(as.character(x) == '0', na.rm = TRUE))
```

Number of unique values of numeric variable `HYLAC`:

```{r}
n_distinct(ws$HYLAC)
```

How many `NA` values for numeric variable `HYLAC`?

Many! So the zeroes were replaced by `NA`.

```{r}
ws$HYLAC %>% is.na %>% sum
```

### Are WVLC codes unique?

No:

```{r}
ws$WVLC %>% unique %>% length == nrow(ws)
```

Which codes are duplicated?

```{r}
ws |> 
  st_drop_geometry() |> 
  count(WVLC) |> 
  filter(n > 1)
```

### Levels for each factor

We can compare the levels for each factor variable with the information given in 
a draft metadata report.

We do not check `NAAM` and `GEBIED` since there are many possible options.

**KRWTYPE**: the codes are correct but there are more codes mentioned in the metadata report.

```{r}
levels(ws$KRWTYPE)
```

**KRWTYPEA** (alternative type): the codes in the spatial layer comply with the metadata report.

```{r}
levels(ws$KRWTYPEA)
```

**KRWTYPES** (status): the codes in the spatial layer are the same as in the metadata report.

```{r}
levels(ws$KRWTYPES)
```

**DIEPKL**: the only codes in the dataset are "0 - 2 m", "2 - 4 m", "4 - 6 m" and "> 6 m"; the codes are different in the metadata report.

```{r}
levels(ws$DIEPKL)
```

Notes:

- in version 1.1, an R chunk in the 'Windows encoding' section already reduced the number of levels, which resulted in fewer extra categories.
However this was just for exploratory purposes as it was not the purpose to always implement such changes.
- also in the future we will not rectify this (by default) in reading functions for raw data sources: problems in the data will be returned as-is and should be solved in a future version of the data source.
By default we just streamline column names and variable types, we make sure that values referring to `NA` are effectively returned as `NA` and we try to avoid some encoding problems.

Because on Windows the ≥/\u2265 character is not well displayed, we will recode it into '=>'
(otherwise "≥" in ws$DIEPKL are rendered as "=" in the html output):

```{r}
levels(ws$DIEPKL) <- gsub(pattern = "\u2265", ">=", levels(ws$DIEPKL))
levels(ws$DIEPKL)
```

**CONNECT**: the codes in the spatial layer are the same as in the metadata report (and they differ from previous official versions).

```{r}
levels(ws$CONNECT)
```

**FUNCTIE**: not present in the database.

```{r collapse=TRUE}
levels(ws$FUNCTIE)
```

And here are the categories in the metadata report for `FUNCTIE`:

functie                       toewijzing
----------------------        ---------------------
natuur                        doelstelling natuurbehoud
hengelintensief               intensief hengelen (met infrastructuur, bepoting of gebruikt voor wedstrijdhengelen)
hengelextensief               extensief hengelen (geen infrastructuur, bepoting of wedstrijdhengelen)
jacht                         jagen
tuin/park                     esthetisch (verblijfsrecreatie, tuin- en parkvijvers)
vogel                         waterpartij voor gedomesticeerde watervogels
viskweek                      opkweken van vis
zwemmen                       zwemmen
duik                          duiken
zachterecreatie               niet gemotoriseerde waterrecreatie
motorrecreatie                gemotoriseerde waterrecreatie
waterberging                       waterberging ten behoeve van overstromings- of peilbeheer
opslag                        reservoir voor water (industrie, landbouw, bluswater, waterkracht…)
drinkwater                    drinkwaterwinning
zuivering                     (kleinschalige) waterzuivering, infiltratie
bezinking                     bezinking van proceswater
veedrenk                      watervoorziening voor vee
geen                          geen specifieke functie

**PEILBEHEER**: one code less than in the report.

```{r}
levels(ws$PEILBEHEER)
```

## Potential issues

- There is a duplicated value of `WVLC`.
- One record has `KRWTYPES` as 'voorlopig'
- `DIEPKL`: codes in the dataset differ from those in the report.
- `KRWTYPE`, `PEILBEHEER`: more levels in the metadata report than in the dataset.
This is not necessarily a problem.
- `FUNCTIE`: not available in the database.

These will be discussed with the authors of the layers.


## Validity of the geometries

Let's inspect features with invalid or corrupt geometry:

```{r}
ws_validity <- st_is_valid(ws)
ws_validity %>% table
invalid_geoms <- ws[!ws_validity | is.na(ws_validity), ]
```

Identifying the invalid geometries:

```{r}
invalid_geoms |> 
  select(WVLC) |> 
  mutate(reason = st_is_valid(invalid_geoms, reason = TRUE)) |> 
  st_drop_geometry()
```

```{r}
tm_shape(invalid_geoms) + tm_borders() + tm_facets(by = "WVLC")
```

The geometry invalidity is the consequence of self-intersecting rings, as a consequence of digitalization errors.

Let's compare with the same geoms after fixing the self-intersecting rings:

```{r}
valid_geoms <- st_make_valid(invalid_geoms)
tm_shape(valid_geoms) + tm_borders() + tm_facets(by = "WVLC")
```

Are all geometries valid now?

```{r}
all(st_is_valid(valid_geoms))
```

So this works well; in derived data we will fix these geometries.
We might also consider an optional geometry reparation step in `read_watersurfaces()`.

We also check that no empty geometries are present:

```{r}
all(!is.na(st_dimension(ws$geometry)))
```


Refer to <https://github.com/inbo/n2khab-preprocessing/issues/60> and <https://r-spatial.org/r/2017/03/19/invalid.html> for more information!

## Let's plot the watersurfaces as a map

```{r plot}

# plot watersurfaces
 p <- ggplot() +
  geom_sf(data = ws, aes(), color = "blue")

# Flanders
sf_vl <- read_admin_areas()

p <- p + 
  geom_sf(data = sf_vl, fill = NA)

print(p)

```

<!-- ### Are all the watersurfaces in Flanders? -->

<!-- ```{r streams-in-fl} -->
<!-- in_vl <- st_contains(x = sf_vl, y = ws) -->

<!-- not_contained <- ws %>%  -->
<!--   st_drop_geometry() %>%  -->
<!--   mutate(orig_rowname = rownames(.)) %>%  -->
<!--   filter(!rownames(.) %in% in_vl[[1]]) -->

<!-- # 61 watersurfaces -->
<!-- print(not_contained %>% nrow()) -->

<!-- not_contained %>%  -->
<!--   distinct(WVLC, NAAM) %>%  -->
<!--   kable() -->
<!-- ``` -->
<!-- 61 watersurfaces are not 'contained' within the polygon for Flanders (see list above) -->

# Tidyverse-styled, internationalized column names when using the data source in R

```{r eval = FALSE}
ws %>% colnames %>% cat(sep = "\n")
```

data source variable          data frame variable
----------------------        ---------------------
`WVLC`                        `polygon_id` 
`WTRLICHC`                    `wfd_code`
`HYLAC`                       `hyla_code`
`NAAM`                        `name`
`GEBIED`                      `area_name`
`KRWTYPE`                     `wfd_type `
`KRWTYPEA`                    `wfd_type_alternative`
`KRWTYPES`                    `wfd_type_certain`
`DIEPKL`                      `depth_class`
`CONNECT`                     `connectivity`
`FUNCTIE`                     `usage`
`PEILBEHEER`                  `water_level_management`

# Other considerations for the R object returned by `read_watersurfaces()`

- not uptaking `OPPWVL`, `OMTWVL`, `SHAPE_Length`, `SHAPE_Area` (area & perimeter are easily calculated etc) -- OK
- sort by `polygon_id` -- OK
- add translations to long text for `wfd_type ` and `connectivity`  -- OK but not by default
- add translations to long text for  `usage`? -- for a later version (as more 
codes will be used)
- converting null / 0 values to `NA` -- OK
- support new variable `water_level_management` -- OK


# Used environment

```{r session-info, results = "asis", echo=FALSE}
si <- sessioninfo::session_info()
p <- si$platform %>%
  do.call(what = "c")
if ("sf" %in% si$packages$package) {
  p2 <- sf::sf_extSoftVersion()
  p2 <- p2[names(p2) != "proj.4"]
  names(p2) <- paste("sf", names(p2))
  p <- c(p, p2)
}
if ("terra" %in% si$packages$package) {
  p2 <- terra::gdal(lib = "all")
  names(p2) <- paste("terra", names(p2) %>% toupper())
  p <- c(p, p2)
}
if ("rgrass" %in% si$packages$package) {
  p <- c(p, GRASS = link2GI::findGRASS()[1, "version"])
}
sprintf("- **%s**: %s\n", names(p), p) %>%
  cat(sep = "")
```

```{r results = "asis", echo=FALSE}
si$packages %>%
    as_tibble %>%
    select(package, loadedversion, date, source) %>%
pander::pandoc.table(caption = "Loaded R packages",
                     split.table = Inf)
```




