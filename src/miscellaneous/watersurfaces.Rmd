---
title: "Handling the watersurfaces data source"
date: "`r paste('Version',lubridate::now())`"
output:
  html_document:
    df_print: paged
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: no
    number_sections: yes
    code_folding: hide
    includes:
      in_header: ../header.html
---

```{r setup, message=FALSE, echo=FALSE}
options(stringsAsFactors = FALSE)
library(sf)
library(tidyverse)
library(tmap)
library(n2khab)
library(knitr)
opts_chunk$set(
  echo = TRUE,
  dpi = 300
)
```

# Exploring the watersurfaces data source

The previous versions were 1.0 (10.5281/zenodo.3386859) and 1.1 (10.5281/zenodo.4117543).
We want to explore the changes in the most recent version: 1.2 (10.5281/zenodo.7440931).

```{r v1.2}
filepath <- file.path(fileman_up("n2khab_data"), "10_raw/watersurfaces/watersurfaces.gpkg")
```

Checksums:

```{r}
filepath %>% 
  n2khab::md5sum() %>% 
  `names<-`("md5sum")
filepath %>% 
  n2khab::sha256sum() %>% 
  `names<-`("sha256sum")
filepath %>% 
  n2khab::xxh64sum() %>% 
  `names<-`("xxh64sum")
```

Import the spatial layer:

```{r}
st_layers(filepath)
```

```{r spatial-layer-v12}
(ws <- read_sf(filepath, stringsAsFactors = TRUE, layer = "Watervlakken"))  # n = 93135
```

Other (aspatial) layers were only available in version 1.1.

## Step-by-step exploration

### Encoding problems (Windows only)

For Windows users, we will need to correct some encoding problems, as shown in the examples hereunder:

```{r encoding-problems, eval=(.Platform$OS.type == "windows")}
osVersion
sessionInfo()$R.version$version.string
sessionInfo()$R.version$platform

ws_diepkl

ws_connect

# 1) spatial layer:

# sf_utf8 <- sf::st_read(filepath, stringsAsFactors = TRUE, layer = "Watervlakken", options = "ENCODING=UTF-8")%>% 
#   filter( WVLC =="ANTMOL0152")
# options = "ENCODING=UTF-8" cannot be used with a geopackage


# as imported by default:
ws %>% st_drop_geometry %>% 
  filter( WVLC =="ANTMOL0152") %>% select(WVLC, DIEPKL, CONNECT)

#conversion latin1 - UTF-8
ws_2 <- n2khab:::convertdf_enc(ws , from = "UTF-8", to = "latin1")
ws_2 %>% st_drop_geometry %>% 
  filter( WVLC =="ANTMOL0152") %>% select(WVLC, DIEPKL, CONNECT)

ws_3 <- n2khab:::convertdf_enc(ws , from = "latin1", to = "UTF-8")
ws_3 %>% st_drop_geometry %>% 
  filter( WVLC =="ANTMOL0152") %>% select(WVLC, DIEPKL, CONNECT)

#conversion WINDOWS-1252 - UTF-8
ws_4 <- n2khab:::convertdf_enc(ws , from = "UTF-8", to = "WINDOWS-1252")
ws_4 %>% st_drop_geometry %>% 
  filter( WVLC =="ANTMOL0152") %>% select(WVLC, DIEPKL, CONNECT)

ws_5 <- n2khab:::convertdf_enc(ws , from = "WINDOWS-1252", to = "UTF-8")
ws_5 %>% st_drop_geometry %>% 
  filter( WVLC =="ANTMOL0152") %>% select(WVLC, DIEPKL, CONNECT)

# 2) non spatial layers:

# latin1 to UTF-8: not OK:
print(n2khab:::convertdf_enc(read_sf(filepath, layer = "LktCONNECT"), from =  "latin1", to ="UTF-8")) 
print(n2khab:::convertdf_enc(read_sf(filepath, layer = "LktDIEPKL"), from =  "latin1", to ="UTF-8")) 

# UTF-8 to latin1: 
print(n2khab:::convertdf_enc(read_sf(filepath, layer = "LktCONNECT"), from = "UTF-8", to = "latin1"))
print(n2khab:::convertdf_enc(read_sf(filepath, layer = "LktDIEPKL"), from = "UTF-8", to = "latin1"))

# UTF-8 to WINDOWS-1252: 
print(n2khab:::convertdf_enc(read_sf(filepath, layer = "LktCONNECT"), from = "UTF-8", to = "WINDOWS-1252"))
print(n2khab:::convertdf_enc(read_sf(filepath, layer = "LktDIEPKL"), from = "UTF-8", to = "WINDOWS-1252"))
  
# UTF-8 to UTF-8: 
print(n2khab:::convertdf_enc(read_sf(filepath, layer = "LktCONNECT"), from = "UTF-8", to = "UTF-8"))
print(n2khab:::convertdf_enc(read_sf(filepath, layer = "LktDIEPKL"), from = "UTF-8", to = "UTF-8"))
   
```

This is a Windows-related problem, so we can add a condition `if (.Platform$OS.type == "windows") { }` to deal with it.

```{r correct-encoding-windows, eval=(.Platform$OS.type == "windows")}
if (.Platform$OS.type == "windows") {
  
# only really needed for CONNECT + a correction for the >= <= in DIEPKL
  
# ws_peilbeheer <- n2khab:::convertdf_enc(ws_peilbeheer, from = "UTF-8", to = "latin1")
# ws_krwtypes <- n2khab:::convertdf_enc(ws_krwtypes, from = "UTF-8", to = "latin1")
# ws_krwtype <- n2khab:::convertdf_enc(ws_krwtype, from = "UTF-8", to = "latin1")
# ws_functie <- n2khab:::convertdf_enc(ws_functie, from = "UTF-8", to = "latin1")
  ws_connect <- n2khab:::convertdf_enc(ws_connect, from = "UTF-8", to = "latin1")

ws_diepkl <- ws_diepkl %>% 
  mutate(Omschr = case_when(
    Code == "2 - 4 m" ~ ">= 2 - < 4 m",
    Code == "4 - 6 m" ~ ">= 4 - < 6 m",
   # Code == "> 6 m" ~ as.character(expression("\u2265 6 m")),
  # Code == "> 6 m" ~ "\u2265 6 m",
   Code == "> 6 m" ~ ">= 6 m",
    TRUE ~ Omschr
  )) 

# How does this look like in html?
# Using one of the following options 
# Code == "> 6 m" ~ as.character(expression("\u2265 6 m")),
# Code == "> 6 m" ~ "\u2265 6 m",
# would look like a "=" in html, so we might be better using an alternative such as ">="

# We will have to do the same for ws (see below)

  }
```

### A summary of the spatial layer for version 1.2

```{r}
ws %>% 
  st_drop_geometry %>% 
  summary
```

`PEILBEHEER` is a new column in version 1.2!

Let us look for a few typical errors more systematically in version 1.2.

### Are there `NA` values?

There are plenty of `NA`'s but only in fields where we expect them.

```{r}
sapply(ws, function(x) sum(is.na(x)))

```

### Are there `<Null>` values?

One `<Null>` string is present in `GEBIED` column:

```{r}
# slow - 25 sec
sapply(ws, function(x) sum(as.character(x) == '<Null>', na.rm = TRUE))
```

### Are there Zero (0) values?

None:

```{r}
# slow - 25 sec
sapply(ws, function(x) sum(as.character(x) == '0', na.rm = TRUE))
```

Previously, `HYLAC` was zero if missing!

Number of unique values of numeric variable `HYLAC`:

```{r}
n_distinct(ws$HYLAC)
```

How many `NA` values for numeric variable `HYLAC`?

Many! So the zeroes were replaced by `NA`.

```{r}
ws$HYLAC %>% is.na %>% sum
```

### Are WVLC codes unique?

Yes. It was not the case in version 1.0, but it has been corrected since v1.1.

```{r}
ws$WVLC %>% unique %>% length
```


### Levels for each factor

We can compare the levels for each factor variable with the information given in 
[Scheers et al. (2022)](https://pureportal.inbo.be/nl/publications/watervlakken-versie-12-polygonenkaart-van-stilstaand-water-in-vla).

We do not check `NAAM` and `GEBIED` since there are many possible options.

**KRWTYPE**: the codes are correct but there are more codes mentioned in the metadata report.

```{r}
levels(ws$KRWTYPE)
```

**KRWTYPES** (status): the codes in the spatial layer are the same as in the metadata report.

```{r}
levels(ws$KRWTYPES)
```

**DIEPKL**: there are extra codes in the dataset ("0 - 2 m", "2 - 4 m", "4 - 6 m" and "> 6 m") and the ordering of the levels could be more logical.

Notes:

- in version 1.1, an R chunk in the 'Windows encoding' section already reduced the number of levels, which resulted in fewer extra categories.
However this was just for exploratory purposes as it was not the purpose to always implement such changes.
- also in the future we will not rectify this (by default) in reading functions for raw data sources: problems in the data will be returned as-is and should be solved in a future version of the data source.
By default we just streamline column names and variable types, we make sure that values referring to `NA` are effectively returned as `NA` and we try to avoid some encoding problems.

```{r}
levels(ws$DIEPKL)

# for Windows users we will recode the levels with => instead of ≥/\u2265 :
# (otherwise "≥" in ws$DIEPKL are rendered as "=" in the html output) 

if (.Platform$OS.type == "windows") {
  
  levels(ws$DIEPKL) <- gsub(pattern = "\u2265", ">=", levels(ws$DIEPKL))
  
  # ws$DIEPKL <- ordered(ws$DIEPKL, levels = c("0 - < 2 m", "0 - 2 m", ">= 2 - < 4 m", ">= 4 - < 6 m", ">= 6 m", "> 6 m"))
  
levels(ws$DIEPKL)
  }

```

**CONNECT**: the codes differ from those in the report, which have the codes from version 1.1.

```{r}
levels(ws$CONNECT)
```

These are the categories in the metadata report for `CONNECT`:

- geïsoleerd: niet verbonden met een waterloop 
- permanent: het watervlak staat permanent in verbinding met minstens één
waterloop 
- periodiek: het watervlak staat tijdelijk (door peilbeheer of droogte) in verbinding
met minstens één waterloop

**FUNCTIE**: the code "veedrenk" is not mentioned in the metadata report and 
there are many more codes in the report than in the 
dataset

```{r}
levels(ws$FUNCTIE)
```

And here are the categories in the metadata report for `FUNCTIE`:

functie                       toewijzing
----------------------        ---------------------
natuur                        doelstelling natuurbehoud
hengelintensief               intensief hengelen (met infrastructuur, bepoting of gebruikt voor wedstrijdhengelen)
hengelextensief               extensief hengelen (geen infrastructuur, bepoting of wedstrijdhengelen)
jacht                         jagen
tuin/park                     esthetisch (verblijfsrecreatie, tuin- en parkvijvers)
vogel                         waterpartij voor gedomesticeerde watervogels
viskweek                      opkweken van vis
zwemmen                       zwemmen
duiken                        duiken
zachterecreatie               niet gemotoriseerde watersport
motorrecreatie                gemotoriseerde watersport
berging                       waterberging ten behoeve van overstromings- of peilbeheer
opslag                        reservoir voor water (industrie, landbouw, bluswater, waterkracht…)
drinkwater                    drinkwaterwinning
zuivering                     (kleinschalige) waterzuivering, infiltratie
bezinking                     bezinking van proceswater
drinkplaats                   watervoorziening voor vee
geen                          geen specifieke functie

**PEILBEHEER**: one code less than in the report.

```{r}
levels(ws$PEILBEHEER)
```

## Potential issues

- `KRWTYPE`, `FUNCTIE`, `PEILBEHEER`: more levels in the metadata report than in the dataset 
- `DIEPKL`, `FUNCTIE`: extra codes in the dataset that are not present in the report
- `CONNECT`: codes differ between dataset and report

The extra codes will be discussed with the authors of the layers.


## Validity of the geometries

Let's inspect features with invalid geometry:

```{r}
st_is_valid(ws) %>% table
invalid_geoms <- ws[!st_is_valid(ws), ]
st_is_valid(invalid_geoms, reason = TRUE)
```

```{r}
tm_shape(invalid_geoms) + tm_borders() + tm_facets(by = "OBJECTID")
```

The geometry invalidity is the consequence of self-intersecting rings, as a consequence of digitalization errors.

Let's compare with the same geoms after fixing the self-intersecting rings:

```{r}
valid_geoms <- st_make_valid(invalid_geoms)
tm_shape(valid_geoms) + tm_borders() + tm_facets(by = "OBJECTID")
```

```{r}
all(st_is_valid(valid_geoms))
```

So this works well; in derived data we will fix these geometries.
We might also consider an optional geometry reparation step in `read_watersurfaces()`.

## Let's plot the watersurfaces as a map

```{r plot}

# plot watersurfaces v1.2
 p <- ggplot() +
  geom_sf(data = ws, aes(), color = "blue")

# Flanders
sf_vl <- read_admin_areas()

p <- p + 
  geom_sf(data = sf_vl, fill = NA)

print(p)

```

<!-- ### Are all the watersurfaces in Flanders? -->

<!-- ```{r streams-in-fl} -->
<!-- in_vl <- st_contains(x = sf_vl, y = ws) -->

<!-- not_contained <- ws %>%  -->
<!--   st_drop_geometry() %>%  -->
<!--   mutate(orig_rowname = rownames(.)) %>%  -->
<!--   filter(!rownames(.) %in% in_vl[[1]]) -->

<!-- # 61 watersurfaces -->
<!-- print(not_contained %>% nrow()) -->

<!-- not_contained %>%  -->
<!--   distinct(WVLC, NAAM) %>%  -->
<!--   kable() -->
<!-- ``` -->
<!-- 61 watersurfaces are not 'contained' within the polygon for Flanders (see list above) -->

# Tidyverse-styled, internationalized column names when using the data source in R

```{r eval = FALSE}
ws %>% colnames %>% cat(sep = "\n")
```

data source variable          data frame variable
----------------------        ---------------------
`WVLC`                        `polygon_id` 
`WTRLICHC`                    `wfd_code`
`HYLAC`                       `hyla_code`
`NAAM`                        `name`
`GEBIED`                      `area_name`
`KRWTYPE`                     `wfd_type `
`KRWTYPES`                    `wfd_type_certain`
`DIEPKL`                      `depth_class`
`CONNECT`                     `connectivity`
`FUNCTIE`                     `usage`
`PEILBEHEER`                  `water_level_management`

**Other considerations for the R object returned by `read_watersurfaces()`**:

- not uptaking `OPPWVL`, `OMTWVL`, `SHAPE_Length`, `SHAPE_Area` (area & perimeter are easily calculated etc) -- OK
- sort by `polygon_id` -- OK
- add translations to long text for `wfd_type ` and `connectivity`  -- OK but not by default
- add translations to long text for  `usage`? -- for a later version (as more 
codes will be used)
- converting null / 0 values to `NA` -- OK

