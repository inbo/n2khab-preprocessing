---
title: "Miscellaneous code chunks"
date: '`r paste("Version",lubridate::now())`'
output:
  html_notebook:
    number_sections: yes
    code_folding: show
    includes:
      in_header: header.html
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: no
---

```{r setup, message=FALSE, echo=FALSE}
options(stringsAsFactors = FALSE)
library(sp)
library(sf)
library(raster)
library(tidyverse)
library(stringr)
library(n2khabutils)
# library(plotly)
library(rasterVis)
```
This is a html notebook which you can use to add your own miscellaneous code,
e.g. to explore some datasets before writing a function to read it,
to prepare for writing functions, 
to test existing n2khabutils functions, etc.

# Exploring the GRTS master grid

## Correcting a flaw in the original version


```{r}
GRTSmaster_habitats <- 
    raster("../data/10_raw/GRTSmaster_habitats/GRTSmaster_habitats.tif")
GRTSmaster_habitats
```

```{r}
inMemory(GRTSmaster_habitats)
```

```{r}
spplot(GRTSmaster_habitats)
```


Oops, see right upper corner. We need to correct this data layer...

First check that the zero value does indeed only occur in the upper right corner:

```{r}
GRTSmaster_habitats[GRTSmaster_habitats == 0,
                    drop = FALSE] %>% 
    spplot
```

Yes, this seems to be a useful criterium.

<!-- ```{r} -->
<!-- flanders <-  st_read("../data/10_raw/flanders") -->
<!-- flanders_500 <-  -->
<!--     flanders %>%  -->
<!--     st_buffer(500) -->
<!-- ``` -->


<!-- ```{r include=FALSE} -->
<!-- # Inspired by code from <https://datacarpentry.org/r-raster-vector-geospatial/08-vector-plot-shapefiles-custom-legend/index.html>, -->
<!-- # however this was too heavy for plotting: -->
<!-- ggplot() + -->
<!--      geom_raster(data = GRTSmaster_habitats %>%  -->
<!--                      as.data.frame(xy = TRUE),  -->
<!--                  aes(x = x,  -->
<!--                      y = y,  -->
<!--                      fill = GRTSmaster_habitats)) + -->
<!--      geom_sf(data = flanders) + -->
<!--      geom_sf(data = flanders_500, -->
<!--              fill = NA, -->
<!--              colour = "red") + -->
<!--     coord_sf() -->
<!-- # compare with: -->
<!-- gplot(GRTSmaster_habitats) + -->
<!--     geom_tile(fill = value) # however, further extension seems difficult here -->
<!-- ``` -->


```{r}
GRTSmaster_mask <- 
    GRTSmaster_habitats %>% 
    reclassify(rcl = c(1, 1e+9, 1,
                       0, 1, NA),
               right = FALSE,
               filename = "../data/20_processed/GRTSmaster_mask",
               overwrite = TRUE)
```

```{r}
GRTSmaster_mask %>% spplot
```


<!-- ```{r} -->
<!-- GRTSmaster_habitats %>% cellStats('countNA') -->
<!-- ``` -->

```{r}
GRTSmaster_simplified <- 
    GRTSmaster_habitats %>% 
    mask(GRTSmaster_mask,
         filename = "../data/20_processed/GRTSmaster_simplified")
```


```{r}
GRTSmaster_simplified %>% spplot
```

How many cells have values, and how many have no value?

```{r}
valueslogical <- 
    !(GRTSmaster_simplified %>% 
    values %>% 
    is.na)
valueslogical %>% 
    table
```

Let's compare the 'TRUE' number with the original data to check completeness:

```{r}
valueslogical_orig <- 
    (GRTSmaster_habitats %>% 
    values) > 0
valueslogical_orig %>% 
    sum(na.rm = TRUE)
```

OK, there is a complete match.

Range of the values:

```{r}
GRTSmaster_simplified %>% 
    values %>%
    summary
```


Let's write the corrected version as a GeoTIFF.

```{r}
GRTSmaster_simplified %>% 
    writeRaster(filename = "../data/20_processed/GRTSmaster_habitats.tif",
                datatype = "INT4S")
```

And now let's check the raster header and its summary, from the newly created GeoTIFF:

```{r}
GRTSmaster_habitats <- 
    raster("../data/20_processed/GRTSmaster_habitats.tif")
GRTSmaster_habitats
```

```{r}
GRTSmaster_habitats %>% 
    spplot
```

## Exploration

### How to make a brick

```{r}
GRTSmaster_habitats <- 
    raster("../data/10_raw/GRTSmaster_habitats/GRTSmaster_habitats.tif")
```


```{r}
GRTSmh_brick <- 
    brick("../data/10_raw/GRTSmaster_habitats/GRTSmaster_habitats.tif")
```

```{r}
inMemory(GRTSmh_brick)
```


```{r}
GRTSmh_brick2 <- 
    brick(list(GRTSmaster_habitats,
            GRTSmaster_habitats %>% 
                reclassify(rcl = c(1, 1e+9, 1),
                           right = FALSE)
        )
    ) %>% 
    writeRaster(filename = file.path(tempdir(), "GRTSmh_brick2.tif"),
                format = "GTiff", 
                overwrite = TRUE)
names(GRTSmh_brick2) <- (c("decimal", "base4"))
GRTSmh_brick2
```


```{r}
inMemory(GRTSmh_brick2)
```

<!-- ```{r} -->
<!-- writeRaster(GRTSmh_brick2, -->
<!--             filename = file.path(tempdir(),"GRTSmh_brick2.tif"), -->
<!--             datatype = "INT4S", -->
<!--             overwrite = TRUE) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- GRTSmh_brick2 <-  -->
<!--     brick(file.path(tempdir(),"GRTSmh_brick2.tif")) -->
<!-- GRTSmh_brick2 -->
<!-- ``` -->

<!-- ```{r} -->
<!-- names(GRTSmh_brick2)  <-  -->
<!--     c("decimal", "base4") -->
<!-- ``` -->

A way to make an empty brick with `nl` layers, based on a specific layer:

```{r eval=FALSE}
brick(brick(GRTSmaster_habitats), nl = 14)
```

But this is MUCH quicker:

```{r}
brick(extent(GRTSmaster_habitats), 
      nrows = 2843, 
      ncols = 7401, 
      nl = 14, 
      crs = crs(GRTSmaster_habitats))
```



### Going from base 10 to base 4: does it make sense?

We make the function `dec2base4()` based on [baseConvert()](https://github.com/graywh/r-gmisc/blob/master/R/baseConvert.R), which is vectorized and does not give a warning compared to `oro.dicom::dec2base()` (besides, it takes long to load the `oro.dicom` package).
The function gives back the base4 fraction, and probably requires 64 bit operation in R (double is 64 bit; plain integer representations (32-bit) were not sufficient, cf. the non-implemented intermediate `bit64::integer64` base4 representation below).

```{r}
options(scipen = 999,
        digits = 15)
```

```{r eval=FALSE}
# scalar function option 1 (with integer64)
dec2base4_s <- 
    function(x) {
        ifelse(is.na(x), NA,
            as.integer64(
                ifelse(x > 0,{
                    d <- floor(log(x, 4) + 1)
                    paste(c("0", "1", "2", "3")[
                        as.integer(abs(diff(x %% 4 ^ seq(d, 0))) %/% 
                                       4 ^ seq(d - 1, 0) + 1)], 
                        collapse = "")
                },
                    '0'
            )) / 10 ^ 13
        )
    }
```

```{r }
# scalar function option 2 (chosen)
dec2base4_s <- 
    function(x) {
        ifelse(is.na(x), NA,
            as.double(
                ifelse(x > 0,{
                    d <- floor(log(x, 4) + 1)
                    paste(c("0", "1", "2", "3")[
                        as.integer(abs(diff(x %% 4 ^ seq(d, 0))) %/% 
                                       4 ^ seq(d - 1, 0) + 1)], 
                        collapse = "")
                },
                    '0'
            )) / 10 ^ 13
        )
    }
```


```{r}
dec2base4 <- 
    function(x) sapply(x, dec2base4_s)
```

Examples:

```{r}
dec2base4(NA)
```


```{r}
dec2base4(37784)
```

The maximum base 4 address in the grid:

```{r}
dec2base4(67108856)
```

It works on vectors with NA values:

```{r}
dec2base4(c(14, 15, NA, 456))
```



Let's look at an extracted portion of the GRTSmaster_habitats grid:

```{r}
GRTS_sub <- 
    GRTSmaster_habitats[2000:2050,3000:3050, drop = FALSE]
GRTS_sub %>% 
    spplot
```

```{r}
GRTS_sub_4 <- 
    GRTS_sub %>% 
    calc(function(x){
            dec2base4(x)
        })
GRTS_sub_4 %>% 
    spplot
```

Check whether we can do the inverse and return the original data (again based on [baseConvert()](https://github.com/graywh/r-gmisc/blob/master/R/baseConvert.R)):

```{r}
basetodec <- function(x, base){
    characters <- c(seq(0,9), LETTERS)
    numbers <- structure(seq(0,35), names = characters)    
    x <- strsplit(as.character(x), "")
    l <- lapply(x, length)
    f1 <- function(x, l) {
        sum(numbers[x] * base ^ (seq(l - 1,0)))
    }
    mapply(f1, x, l)
}
```

```{r}
GRTS_sub_4 %>% 
    calc(function(x) basetodec(x * 10 ^ 13, base = 4)) %>% 
    all.equal(GRTS_sub)
```

Olé.

```{r}
stack(GRTS_sub, GRTS_sub_4) %>% 
                    values %>% 
                    as_tibble %>% 
                    as.matrix %>% 
                    head(10)
```

This seems to work perfectly with this raster.
However it seems to stuck when NA values are present in the raster, see further.

But first, does it make sense spatially; are the original GRTS addresses still reflected in this base4-conversion? Let's extract the 2nd to 6th digit and look at the pattern:

```{r}
max_digits <- 
    c(GRTSmaster_habitats@data@max,
      GRTSmaster_habitats@data@max - 1) %>% 
    dec2base4 %>% 
    as.character %>% 
    (function(x) str_length(x) - 2) %>% 
    max
```

```{r}
extract_digit <- 
    function(x, level, max_digits) {
        withr::with_options(
                  c(scipen = 999), 
                  str_pad(x, max_digits, pad = "0")
                  ) %>% 
            str_sub(level, level) %>% 
            as.numeric
    }
```

```{r}
extract_digit(3333333333320, level = 12, max_digits = max_digits)
```


```{r}
for (i in 2:6) {
GRTS_sub_4 %>% 
    calc(function(x) extract_digit(x * 10 ^ 13, 
                                   level = i, 
                                   max_digits = max_digits)) %>% 
        spplot %>% 
        print
}
```

Yeeha.

We want to be able to aggregate other spatial data at the respective hierarchical levels, and still return this in a spatial way, at the desired level.
Also, at each level we want to have the reverse hierarchical ordering available at that level, so the complete address at that level must be returned.
We will use base 4 **fractions** as address (cf. Stevens & Olsen 2004) as this seems to be more convenient to calculate such an address at each level.

We have two options to implement this:

- do the processing in a dataframe context (group by a specific level, and using simple functions to go to base 4 and calculate the desired grouping level), and then go back to a raster.
However, here we still want to be able not only to use the 32m² raster but also to work with a coarser raster (which is lighter to handle).
- or we do raster calculations only. A brick could even be made that holds the respective levels, but this will still be at the 32 m² level, so quite a burden to calculate.
But that would need to be done only once.

An advantage in both cases is that the coupling between base 10 rank and base 4 addresses is maintained for each raster cell.

So, which is more convenient / feasible?

#### Doing raster calculations only

At this moment, I simply don't get to work the `dec2base4()` function to work within `calc()` when the raster contains NA values.
See the example below: its results contain numbers higher than 3 for the last digits; very strange...

So we'll have to go for the dataframe approach for now, at least for the calculation of the full base4 fraction and its derived levels.
We will still need raster versions of these addresses and levels, in order to have spatial context.

===

Illustration of failure of the `calc()` approach when the raster has NAs. It makes me wonder: is there a bug in my code or in `raster::calc()`...
I guess `raster::calc()` doesn't cope so well with NA's in a raster.
Tried things in a variety of ways, see above and before.

```{r}
# options(error = browser())
# dec2base4_raster <- 
#     function(x){
#             ifelse(is.na(x), NA,
#                    as.numeric(dec2base4(x))
#             )
#                    }
sub10 <- GRTSmaster_habitats[1000:1030, 660:690, drop = FALSE]
sub10 %>% spplot
```

```{r}
system.time(
    GRTSmh_base4 <-
    sub10 %>% 
    calc(dec2base4,
        filename = "../data/20_processed/GRTSmh_base4.tif",
        # forcefun = TRUE,
        overwrite = TRUE)
)
```

```{r}
stack(sub10, GRTSmh_base4) %>% 
                    values %>% 
                    as_tibble %>% 
                    filter(!is.na(layer)) %>% 
                    as.matrix %>% 
                    head(10)
```

===


#### Working via a dataframe representation

Let's just try and see if after doing some math in a dataframe, we can nicely turn the dataframe into a brick layer:

```{r}
sub10brick <- brick(list(sub10,
                         sub10)) %>% 
    writeRaster(filename = file.path(tempdir(), "test.tif"),
                format = "GTiff", 
                overwrite = TRUE)
names(sub10brick) <- c("decimal", "base4frac")
inMemory(sub10brick)
values(sub10brick$base4frac) <- 
    sub10brick$decimal[] %>% 
    enframe %>% 
    mutate(base4frac = dec2base4(value)) %>% 
    arrange(name) %>% 
    pull(base4frac)
sub10brick %>% 
    writeRaster(filename = file.path(tempdir(), "test.tif"),
                format = "GTiff", 
                overwrite = TRUE)
```



The last digit shows some odd behaviour, in that one expects nearby cells to have the same digit at a high level.
The last digit switches from 0 to 1 quite often.
We'll ignore it for now, but it seems there is a bug waiting there to be resolved.

Checking the result, this look nice:

```{r}
sub10brick[c(60:65,90:100)]
```

Plot the new layer:

```{r}
sub10brick$base4frac %>% spplot
```


If we read back in from the file, do we get exactly the same?

```{r}
brick(file.path(tempdir(), "test.tif"))[c(60:65,90:100)]
```

NOPE! So this seems to have to do with the data type.

```{r}
dataType(sub10brick$decimal)
```

```{r}
dataType(sub10brick$base4frac)
```



### Climbing up the GRTS hierarchical level

And now, for a more simple try to work further within the raster...

```{r}
sub10brick <- brick(list(sub10brick,
                         sub10brick$base4frac)) %>% 
                writeRaster(filename = file.path(tempdir(), "test.tif"),
                format = "GTiff", 
                overwrite = TRUE)
names(sub10brick) <- c("decimal", "base4frac", "base4frac_2")
inMemory(sub10brick)
sub10brick$base4frac_2 <- 
    sub10brick$base4frac %>% 
    calc(function(x) {
        a <- x * 10
        round(a - floor(a), 12)
    })
```

Inspect the results:

```{r}
sub10brick[c(60:65,90:100)]
```

Howdi holy - sometimes calc() yields nonsense again, and sometimes not!
And, in case of nonsense, the data in the base4frac layer get corrupt!
This is rather worrying.

However, cannot reproduce that again, very strange...

It's nice to know that things can be reproduced from the dataframe, however.

```{r}
sub10brick$base4frac_2 %>% spplot
```

Let's do another one, 2 levels up:

```{r}
sub10brick <- brick(list(sub10brick,
                         sub10brick$base4frac)) %>% 
                writeRaster(filename = file.path(tempdir(), "test.tif"),
                format = "GTiff", 
                overwrite = TRUE)
names(sub10brick) <- c("decimal", 
                       "base4frac", 
                       "base4frac_2",
                       "base4frac_4")
inMemory(sub10brick)
sub10brick$base4frac_2 <- 
    sub10brick$base4frac %>% 
    calc(function(x) {
        a <- x * 1000
        round(a - floor(a), 10)
    })
```

Inspect the results:

```{r}
sub10brick[c(60:65,90:100)]
```

DAMN IT!
All is lost now.
I'll stop doing this with the calc() function

And it seems that even via dataframes problems pop up once we come in the raster stage!

```{r eval=FALSE}
sub10brick <- brick(list(sub10brick,
                         sub10brick$base4frac,
                         sub10brick$base4frac)) %>% 
                writeRaster(filename = file.path(tempdir(), "test.tif"),
                format = "GTiff", 
                overwrite = TRUE)
names(sub10brick) <- c("decimal", 
                       "base4frac", 
                       "base4frac_2",
                       "base4frac_4")
values(sub10brick$base4frac_4) 
sub10brick$base4frac[] %>% 
    enframe %>% 
    mutate(base4frac_4 = dec2base4(value)) %>% 
    arrange(name) %>% 
    pull(base4frac)
```

The problems _may_ be overcome by using `bit64::as.integer64()` and the `INT4U` dataType, but a few first tries gave other problems, so this line ends here.

**To conclude:**

- it appears that the long base4 numbers are held well in memory, but are badly saved in files.
- for rasters, we will only use the _decimal_ integer numbers...
- we will use the dataframe representation:
    - for the base4 fraction calculation and storage (and if that goes wrong, 
    we opt for the string representation of the base4 address!)
    - for the different levels of the fraction
    - for converting _those_ levels back to a decimal number
    
    As this is large data, it may come in handy to use specific methods (see [tutorial](https://inbo.github.io/tutorials/tutorials/r_large_data_files_handling/))
- we will use converted decimal numbers for reconstructing lower-resolution rasters. No more bricks needed, as these don't support different resolutions.







