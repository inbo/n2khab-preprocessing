---
title: "Miscellaneous code chunks"
date: '`r paste("Version",lubridate::now())`'
output:
  html_notebook:
    number_sections: yes
    code_folding: show
    includes:
      in_header: header.html
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: no
---

```{r setup, message=FALSE, echo=FALSE}
options(stringsAsFactors = FALSE)
library(sp)
library(sf)
library(raster)
library(tidyverse)
library(stringr)
library(n2khabutils)
# library(plotly)
library(rasterVis)
```
This is a html notebook which you can use to add your own miscellaneous code,
e.g. to explore some datasets before writing a function to read it,
to prepare for writing functions, 
to test existing n2khabutils functions, etc.

# Exploring the GRTS master grid

## Correcting a flaw in the original version


```{r}
GRTSmaster_habitats <- 
    raster("../data/10_raw/GRTSmaster_habitats/GRTSmaster_habitats.tif")
GRTSmaster_habitats
```

```{r}
inMemory(GRTSmaster_habitats)
```

```{r}
spplot(GRTSmaster_habitats)
```


Oops, see right upper corner. We need to correct this data layer...

First check that the zero value does indeed only occur in the upper right corner:

```{r}
GRTSmaster_habitats[GRTSmaster_habitats == 0,
                    drop = FALSE] %>% 
    spplot
```

Yes, this seems to be a useful criterium.

<!-- ```{r} -->
<!-- flanders <-  st_read("../data/10_raw/flanders") -->
<!-- flanders_500 <-  -->
<!--     flanders %>%  -->
<!--     st_buffer(500) -->
<!-- ``` -->


<!-- ```{r include=FALSE} -->
<!-- # Inspired by code from <https://datacarpentry.org/r-raster-vector-geospatial/08-vector-plot-shapefiles-custom-legend/index.html>, -->
<!-- # however this was too heavy for plotting: -->
<!-- ggplot() + -->
<!--      geom_raster(data = GRTSmaster_habitats %>%  -->
<!--                      as.data.frame(xy = TRUE),  -->
<!--                  aes(x = x,  -->
<!--                      y = y,  -->
<!--                      fill = GRTSmaster_habitats)) + -->
<!--      geom_sf(data = flanders) + -->
<!--      geom_sf(data = flanders_500, -->
<!--              fill = NA, -->
<!--              colour = "red") + -->
<!--     coord_sf() -->
<!-- # compare with: -->
<!-- gplot(GRTSmaster_habitats) + -->
<!--     geom_tile(fill = value) # however, further extension seems difficult here -->
<!-- ``` -->


```{r}
GRTSmaster_mask <- 
    GRTSmaster_habitats %>% 
    reclassify(rcl = c(1, 1e+9, 1,
                       0, 1, NA),
               right = FALSE,
               filename = "../data/20_processed/GRTSmaster_mask",
               overwrite = TRUE)
```

```{r}
GRTSmaster_mask %>% spplot
```


<!-- ```{r} -->
<!-- GRTSmaster_habitats %>% cellStats('countNA') -->
<!-- ``` -->

```{r}
GRTSmaster_simplified <- 
    GRTSmaster_habitats %>% 
    mask(GRTSmaster_mask,
         filename = "../data/20_processed/GRTSmaster_simplified")
```


```{r}
GRTSmaster_simplified %>% spplot
```

How many cells have values, and how many have no value?

```{r}
valueslogical <- 
    !(GRTSmaster_simplified %>% 
    values %>% 
    is.na)
valueslogical %>% 
    table
```

Let's compare the 'TRUE' number with the original data to check completeness:

```{r}
valueslogical_orig <- 
    (GRTSmaster_habitats %>% 
    values) > 0
valueslogical_orig %>% 
    sum(na.rm = TRUE)
```

OK, there is a complete match.

Range of the values:

```{r}
GRTSmaster_simplified %>% 
    values %>%
    summary
```


Let's write the corrected version as a GeoTIFF.

```{r}
GRTSmaster_simplified %>% 
    writeRaster(filename = "../data/20_processed/GRTSmaster_habitats.tif",
                datatype = "INT4S")
```

And now let's check the raster header and its summary, from the newly created GeoTIFF:

```{r}
GRTSmaster_habitats <- 
    raster("../data/20_processed/GRTSmaster_habitats.tif")
GRTSmaster_habitats
```

```{r}
GRTSmaster_habitats %>% 
    spplot
```

## Exploration

### How to make a brick

```{r}
GRTSmaster_habitats <- 
    raster("../data/10_raw/GRTSmaster_habitats/GRTSmaster_habitats.tif")
```


```{r}
GRTSmh_brick <- 
    brick("../data/10_raw/GRTSmaster_habitats/GRTSmaster_habitats.tif")
```

```{r}
inMemory(GRTSmh_brick)
```


```{r}
GRTSmh_brick2 <- 
    brick(list(GRTSmaster_habitats,
            GRTSmaster_habitats %>% 
                reclassify(rcl = c(1, 1e+9, 1),
                           right = FALSE)
        )
    ) %>% 
    `names<-`(c("decimal", "base4"))
GRTSmh_brick2
```


```{r}
inMemory(GRTSmh_brick2)
```

<!-- ```{r} -->
<!-- writeRaster(GRTSmh_brick2, -->
<!--             filename = file.path(tempdir(),"GRTSmh_brick2.tif"), -->
<!--             datatype = "INT4S", -->
<!--             overwrite = TRUE) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- GRTSmh_brick2 <-  -->
<!--     brick(file.path(tempdir(),"GRTSmh_brick2.tif")) -->
<!-- GRTSmh_brick2 -->
<!-- ``` -->

<!-- ```{r} -->
<!-- names(GRTSmh_brick2)  <-  -->
<!--     c("decimal", "base4") -->
<!-- ``` -->


### Going from base 10 to base 4: does it make sense?

We use the following function from [here](https://github.com/graywh/r-gmisc/blob/master/R/baseConvert.R), which is vectorized and does not give a warning compared to `oro.dicom::dec2base()` (besides, it takes long to load the `oro.dicom` package):

```{r}
source("../n2khabutils/R/baseConvert.R")
```



```{r}
baseConvert(37784, target = 4)
```

The maximum base 4 address in the grid:


```{r}
baseConvert(67108856, target = 4)
```



Let's look at an extracted portion of the GRTSmaster_habitats grid:

```{r}
GRTS_sub <- 
    GRTSmaster_habitats[2000:2050,3000:3050, drop = FALSE]
GRTS_sub %>% 
    spplot
```

```{r}
GRTS_sub_4 <- 
    GRTS_sub %>% 
    calc(function(x){
            as.numeric(baseConvert(x, target = 4))
        })
GRTS_sub_4 %>% 
    spplot
```

```{r}
baseConvert(100, target = 10, base = 4)
```

```{r}
GRTS_sub_4 %>% 
    calc(function(x) baseConvert(x, target = 10, base = 4)) %>% 
    all.equal(GRTS_sub)
```

Olé.

But, does it make sense spatially; are the original GRTS addresses still reflected in this base4-conversion? Let's extract the 2nd to 6th digit and look at the pattern:

```{r}
max_digits <- 
    GRTS_sub_4 %>% 
    values %>% 
    max %>% 
    as.character %>% 
    str_length
```

```{r}
extract_digit <- 
    function(x, level, max_digits) {
        withr::with_options(
                  c(scipen = 999), 
                  str_pad(x, 13, pad = "0")
                  ) %>% 
            str_sub(level, level) %>% 
            as.numeric
    }
```

```{r}
extract_digit(3333333333320, level = 12, max_digits = max_digits)
```


```{r}
for (i in 2:6) {
GRTS_sub_4 %>% 
    calc(function(x) extract_digit(x, level = i, max_digits = max_digits)) %>% 
        spplot %>% 
        print
}
```

Yeeha.

We want to be able to aggregate other spatial data at the respective hierarchical levels, and still return this in a spatial way, at the desired level.
Also, at each level we want to have the reverse hierarchical ordering available at that level, so the complete address at that level must be returned.
We will use base 4 **fractions** as address (cf. Stevens & Olsen 2004) as this seems to be more convenient to calculate such an address at each level.

We have two options to implement this:

- do the processing in a dataframe context (group by a specific level, and using simple functions to go to base 4 and calculate the desired grouping level), and then go back to a raster.
However, here we still want to be able not only to use the 32m² raster but also to work with a coarser raster (which is lighter to handle).
- or we do raster calculations only. A brick could even be made that holds the respective levels, but this will still be at the 32 m² level, so quite a burden to calculate.
But that would need to be done only once.

An advantage in both cases is that the coupling between base 10 rank and base 4 addresses is maintained for each raster cell.

So, which is more convenient / feasible?

At this moment, I simply don't get to work the `baseConvert()` function to work within `calc()` when the raster contains NA values. The best approach seems to be the below one, but its results contain numbers higher than 3 for the last digits; very strange...

So we'll have to go for the dataframe approach for now, at least for the calculation of the full base4 address.

===

Illustration of failure of the `calc()` approach:

```{r}
# options(error = browser())
dec2base_raster <- 
    function(x){
            as.numeric(baseConvert(x, target = 4))                    }
sub10 <- GRTSmaster_habitats[1:50, , drop = FALSE]
system.time(
    GRTSmh_base4 <- 
    sub10 %>% 
    calc(dec2base_raster,
        filename = "../data/20_processed/GRTSmh_base4.tif",
        forceapply = TRUE,
        overwrite = TRUE)
)
```

```{r}
withr::with_options(c(scipen = 999),
                    stack(sub10, GRTSmh_base4) %>% 
                    values %>% 
                    as_tibble %>% 
                    filter(!is.na(layer))
)
```

===




















