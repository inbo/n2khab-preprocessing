# Introduction

## Current, intermediate state of the `shallowgroundwater` data source

A `shallowgroundwater` data source was prepared by Dries Adriaens and colleagues in order to delineate the areas in Flanders where the Mean Lowest Watertable ('GLG') is located higher (less deep) than approx. 1.5 - 2 m below soil surface.
This data source is needed to restrict the target population of several MNE [monitoring](https://github.com/inbo/n2khab-monitoring) schemes in the groundwater compartiment.
It is more specifically applied to restrict the 'locally groundwater dependent' types, i.e. to discard the sites without shallow groundwater.

- Data and metadata are in [a GDrive folder](https://drive.google.com/drive/u/0/folders/1S9colwuaMNmB58u4RUnB0MqZLyIUZ9rT).
- More info about checking the data source: see <https://github.com/inbo/n2khab-mne-design/pull/74> and links therein.

Based on an evaluation that uses the '(almost) everywhere groundwater dependent' types, the current state still mismatches a significant proportion of those types.
Hence, the area it covers needs to be made broader.

## Aim and method {#method}

In this document, we append several layers to `shallowgroundwater`.
The **aim** is to select areas which `shallowgroundwater` doesn't cover yet and where '(almost) everywhere groundwater dependent' types (here also called 'obliggwdep' types) are present.
Such 'areas of interest' are e.g. anthropogenic soil type polygons, and a ring around the borders of `shallowgroundwater`.

- In order not to exaggerate the extension of `shallowgroundwater`, we will subseqently limit those areas to _buffers (of `r params$buffer_obliggwdep` m) around habitatmap polygons with 'obliggwdep' types_ -- still subsequently clipping along the borders of the aforementioned areas.
So in practice, we first select the habitatmap polygons with 'obliggwdep' types that intersect the areas of interest, we buffer them, and we clip the result along the areas of interest.
  - The buffers around habitatmap polygons with 'obliggwdep' types are applied since it is expected that shallow groundwater (with potentially 'locally groundwater dependent' types) will occur in the vicinity of those polygons.
- In a next step, we want to add a _buffer of 200 m_ around the resulting polygons.
This is done as a further means of conservative area selection: we rather need too much area than too little, for protection against over-restricting target populations.

The areas of interest are:

- all _anthropogenic soil type polygons_: i.e. where the `bsm_mo_soilunitype` column of the `soilmap_simple` data source starts with `"O"`;
- a _ring around_ `shallowgroundwater` of 200 m wide.

Regarding the anthropogenic soil type polygons, from earlier evaluation it appeared that the _narrow ones that contain 'obliggwdep' types_ are interesting as a whole.
Hence we select them as a whole instead of selecting buffers around the habitatmap polygons with 'obliggwdep' types.
And also in this case we end by finally adding a buffer of 200 m to these soil type polygons.

- An appropriate algorithm had to be made that selects meaningful polygons - at first it resulted in complete cities meeting the narrowness requirement (since they are part of anthropogenic soil type polygons with long, narrow parts).
- Hence an additional condition was required: a minimal amount of 'obliggwdep' type must be present in such polygons.

Finally, we append the parts -- of all new layers -- that don't overlap `shallowgroundwater`, to `shallowgroundwater`.
The resulting new version of `shallowgroundwater` is written here as **`sg_extended.gpkg`**.

Hence we will have three separate sources, which we will document as three extra TRUE/FALSE column inside `sg_extended.gpkg`:

- `within_soilanthrop_plus_buffer`
- `narrow_soilanthrop_plus_buffer`
- `nearby_originalsg_plus_buffer`

Where an area overlapped between several of these sources, more than one column is set as `TRUE`.

We do most geoprocessing tasks using `sf` (mostly using GEOS as backend).
However in some cases we use `qgisprocess` (QGIS as backend) when the QGIS algorithm is either faster than, or absent from, `sf`.


# Preparation

## Data setup and checks

```{r}
local_root <- find_root(has_file("update_shallowgroundwater.Rproj"))
datapath <- file.path(local_root, "data")
if (!dir.exists(datapath)) dir.create(datapath)
sgpath <- find_root_file("n2khab_data/10_raw/shallowgroundwater", 
                            criterion = has_dir("n2khab_data"))

if (!dir.exists(sgpath) | list.files(sgpath) %>% length == 0) {
  dir.create(sgpath)
  drive_auth(email = TRUE)
  # downloads "ZonesOndiepGrondwater_2019-03-29.zip":
  as_id("1n_LyvRDDzL3hraoMWf_pBhabTYiWsiD0") %>% 
    drive_download(file.path(tempdir(), "file.zip"), 
                   overwrite = TRUE)
  unzip(file.path(tempdir(), "file.zip"), 
        exdir = sgpath)
  filenames <- list.files(sgpath, full.names = TRUE)
  file.rename(filenames,
              str_replace(filenames, 
                          "ZonesOndiepGrondwater", 
                          "shallowgroundwater"))
}
```

Verification of several input data sets.

Checksums of `shallowgroundwater` (using default algorithm of `n2khab::checksum()`):

```{r}
checksums <- 
  list.files(sgpath, full.names = TRUE) %>% 
  checksum
checksums %>% 
  as.matrix
```

```{r}
if (any(checksums != 
        c(shallowgroundwater.cpg = "a0915c78be995614",
          shallowgroundwater.dbf = "c4ceda6d9466bd89", 
          shallowgroundwater.qpj = "853f02064884203e",
          shallowgroundwater.sbn = "cb0c0bb2565829ff", 
          shallowgroundwater.sbx = "9419203dc2909044",
          shallowgroundwater.shp = "5cf8969daa942dec", 
          shallowgroundwater.shp.xml = "6df16307066eec5e",
          shallowgroundwater.shx = "bc582622278dba1c"))
) warning("Beware, your version of shallowgroundwater is not the one for which this code was intended!")
```

```{r}
sspath <- find_root_file("n2khab_data/20_processed/soilmap_simple/soilmap_simple.gpkg", 
                            criterion = has_dir("n2khab_data"))
if (!file.exists(sspath)) stop("Please organize soilmap_simple location. See e.g. https://inbo.github.io/n2khab/articles/v022_example.html")
if (checksum(sspath) != "9f4204b476506031") stop("Incorrect soilmap_simple version.")

hmtpath <- find_root_file("n2khab_data/20_processed/habitatmap_terr/habitatmap_terr.gpkg", 
                            criterion = has_dir("n2khab_data"))
if (!file.exists(hmtpath)) stop("Please organize habitatmap_terr location. See https://inbo.github.io/n2khab")
if (checksum(hmtpath) != "72d3144016e816ed") stop("Incorrect habitatmap_terr version.")
```

Reading data sets.

```{r}
soilmap <- read_soilmap()
```

```{r include=FALSE}
gpkg_sg_exists <- 
  file.exists(file.path(datapath, 
                        "sg_repairedgeom.gpkg"))
```

```{r eval=!gpkg_sg_exists}
sg <- read_sf(sgpath, crs = 31370)
```

```{r eval=FALSE, echo=FALSE}
# Preparatory exploration of anthropogenic areas:
read_soilmap(use_processed = FALSE) %>% 
  st_drop_geometry %>% 
  filter(str_sub(bsm_mo_soilunitype, 1, 1) == "O") %>% 
  count(bsm_mo_soilunitype, 
           bsm_soilseries, 
           bsm_soilseries_explan,
           bsm_ge_series,
           bsm_ge_series_explan)
```

## Preparing derived input data

Constructing the geospatial and attribute data of `habitatmap_terr` polygons that contain 'obliggwdep' types, relevant in the MNE monitoring programme.

```{r message = FALSE, warning = FALSE}
scheme_types_mne_expanded <-
  read_scheme_types(extended = TRUE) %>%
  filter(programme == "MNE") %>%
  distinct(scheme, type) %>%
  group_by(scheme) %>%
  expand_types %>%
  ungroup
types_obliggwdep <-
  read_types() %>% 
  filter(groundw_dep == "GD2") %>%
  select(type) %>% 
  # following step does 2 things: 
  # - drop 6 (main) type codes that don't appear in habitatmap_terr
  # - avoid 7110, which we don't recognize within MNE (one location in habitatmap_terr)
  semi_join(scheme_types_mne_expanded, by = "type")
hmt <- read_habitatmap_terr(keep_aq_types = FALSE)
hmt_occ_obliggwdep <- 
  hmt$habitatmap_terr_types %>% 
  semi_join(types_obliggwdep,  
            by = "type")
hmt_pol_obliggwdep <- 
  hmt$habitatmap_terr_polygons %>% 
  select(polygon_id, description_orig) %>% 
  semi_join(hmt_occ_obliggwdep,
            by = "polygon_id")
st_agr(hmt_pol_obliggwdep) <- "constant"
```

Creating a geospatial object of anthropogenic soil type polygons, and calculate a property 'thinness' (from [here](https://tereshenkov.wordpress.com/2014/04/08/fighting-sliver-polygons-in-arcgis-thinness-ratio/)) -- lower means more narrow -- as well as the areal fraction occupied by `habitatmap_terr` polygons having 'obliggwdep' types.

```{r}
soil_anthrop <- 
  soilmap %>% 
  filter(str_sub(bsm_mo_soilunitype, 1, 1) == "O") %>% 
  select(bsm_poly_id, bsm_mo_soilunitype) %>% 
  mutate(perimeter = lwgeom::st_perimeter(.),
         area = st_area(.),
         thinness =  4 * pi * (area / perimeter ^2) %>% drop_units()) %>% 
  st_make_valid()
st_agr(soil_anthrop) <- "constant"
soil_anthrop_occupied <- 
  soil_anthrop %>% 
  st_intersection(hmt_pol_obliggwdep) %>% 
  mutate(subarea = st_area(.)) %>% 
  st_drop_geometry %>% 
  group_by(bsm_poly_id) %>% 
  summarise(obliggwdep_pol_frac = drop_units(sum(subarea) / first(area)))
soil_anthrop <- 
  soil_anthrop %>% 
  left_join(soil_anthrop_occupied,
            by = "bsm_poly_id")
```

The distribution of both calculated variables:

```{r warning=FALSE, out.width='70%'}
soil_anthrop %>% 
  st_drop_geometry %>% 
  ggplot(aes(x = thinness)) + 
  geom_histogram(binwidth = 0.01, fill = "white", colour = "grey70")
soil_anthrop %>% 
  st_drop_geometry %>% 
  ggplot(aes(x = obliggwdep_pol_frac)) + 
  geom_histogram(binwidth = 0.01, fill = "white", colour = "grey70")
```

# Execution

## Generating the areas of interest (where shallow groundwater is more probable)

### Buffer `r params$buffer_obliggwdep` m around obliggwdep types, within `soil_anthrop`

We create this geospatial object and also write it as a GPKG file, since the calculation takes several minutes.

```{r include=FALSE}
gpkg_exists <- 
  file.exists(file.path(datapath, 
                        "buffered_obliggwdep_within_soilanthrop.gpkg"))
```

```{r eval=!gpkg_exists || params$rewrite_intermediate_files}
# following step takes several minutes!
buffered_obliggwdep_within_soilanthrop <-
  hmt_pol_obliggwdep[soil_anthrop, ] %>% 
  st_make_valid(.) %>% 
  st_buffer(params$buffer_obliggwdep) %>% 
  st_union() %>% 
  st_intersection(soil_anthrop)
write_sf(buffered_obliggwdep_within_soilanthrop, 
         file.path(datapath, 
                   "buffered_obliggwdep_within_soilanthrop.gpkg"),
         delete_dsn = TRUE)
```

```{r eval=gpkg_exists && !params$rewrite_intermediate_files, include = FALSE}
buffered_obliggwdep_within_soilanthrop <- 
  read_sf(file.path(datapath, 
                    "buffered_obliggwdep_within_soilanthrop.gpkg"))
```

Resulting object: `buffered_obliggwdep_within_soilanthrop`.

### Narrow anthropogenic soil polygons with 'obliggwdep' types

After several iterations, the below used conditions on `thinness` and `obliggwdep_pol_frac` appeared satisfying.

```{r}
narrow_soilanthrop_with_obliggwdep <- 
  soil_anthrop %>% 
  filter(thinness < 0.15,
         obliggwdep_pol_frac > 0.04) %>% 
  st_cast("MULTIPOLYGON")
```

Interactive map:

```{r out.width='800px', out.height='500px'}
mapview(narrow_soilanthrop_with_obliggwdep,
        zcol = "thinness",
        color = "pink3",
        lwd = 2)
```

Resulting object: `narrow_soilanthrop_with_obliggwdep`.

### Buffer `r params$buffer_obliggwdep` m around obliggwdep types, within a ring of 200 m around `shallowgroundwater`

We will first create a ring around `shallowgroundwater` of 200 m width.

```{r eval=!gpkg_sg_exists}
sg_repairedgeom <- 
  st_make_valid(sg) %>% 
  st_cast("MULTIPOLYGON")
write_sf(sg_repairedgeom,
         file.path(datapath, 
                   "sg_repairedgeom.gpkg"),
         delete_dsn = TRUE)
```

```{r eval=gpkg_sg_exists, include=FALSE}
sg_repairedgeom <- 
  read_sf(file.path(datapath, 
                    "sg_repairedgeom.gpkg"))
```

```{r include=FALSE}
gpkg_sg_ring_exists <- 
  file.exists(file.path(datapath, 
                        "sg_ring.gpkg"))
```

```{r eval=!gpkg_sg_ring_exists}
system.time({
sg_union <-
  sg_repairedgeom %>%
  st_union()
sg_buff <-
  sg_union %>%
  st_buffer(200)
sg_ring <- 
  st_difference(sg_buff, sg_union)
})
#     user   system  elapsed 
# 2044.543    0.000 2045.678 
write_sf(sg_ring, 
         file.path(datapath, 
                   "sg_ring.gpkg"),
         delete_dsn = TRUE)
```

```{r eval=gpkg_sg_ring_exists, include=FALSE}
sg_ring <- 
  read_sf(file.path(datapath, 
                    "sg_ring.gpkg"))
```

Then we create the buffered habitatmap polygons with 'obliggwdep' types within the ring.

```{r eval=FALSE, echo=FALSE}
# following step takes too much time! Interrupted this manually.
system.time(
buffered_obliggwdep_nearsg <-
  hmt_pol_obliggwdep[sg_ring, ] %>% # especially this takes an age. Will use QGIS here.
  st_make_valid(.) %>% 
  st_buffer(params$buffer_obliggwdep) %>% 
  st_union()
)
```

```{r include=FALSE}
gpkg_buffered_obliggwdep_within_sg_ring_exists <- 
  file.exists(file.path(datapath, 
                        "buffered_obliggwdep_within_sg_ring.gpkg"))
```

```{r eval=!gpkg_buffered_obliggwdep_within_sg_ring_exists || params$rewrite_intermediate_files}
# qgis_algorithms() %>% filter(str_detect(algorithm, "extract"))
# qgis_show_help("native:extractbylocation")
hmt_pol_obliggwdep %>% 
  st_make_valid %>% 
  write_sf(file.path(datapath, 
                     "hmt_pol_obliggwdep.gpkg"),
           delete_dsn = TRUE)
```


```{r}
plan(multisession) # future kept here as demonstration
```


```{r eval=!gpkg_buffered_obliggwdep_within_sg_ring_exists || params$rewrite_intermediate_files, warning=FALSE}
# use of future unneeded in this case (runs quickly; however
# hmt_pol_obliggwdep[sg_ring, ] takes very long)
f <- future({
  qgis_run_algorithm("native:extractbylocation",
                       INPUT = file.path(datapath, 
                                         "hmt_pol_obliggwdep.gpkg"),
                       PREDICATE = 0,
                       INTERSECT = file.path(datapath, 
                                             "sg_ring.gpkg"))
}, seed = NULL)
# resolved(f)
obliggwdep_sgring_qgis <- value(f, stdout = FALSE) # blocks calling R session if !resolved(f)
```


```{r eval=!gpkg_buffered_obliggwdep_within_sg_ring_exists || params$rewrite_intermediate_files, warning=FALSE}
# use of future unneeded in this case (runs quickly)
f <- future({
  elapsed <- 
    system.time(
      result <-
        obliggwdep_sgring_qgis$OUTPUT %>% 
        read_sf %>% 
        st_buffer(params$buffer_obliggwdep) %>% 
        st_union() %>% 
        st_intersection(sg_ring)
    )
  list(result = result, elapsed = elapsed)
}, seed = NULL)
# resolved(f)
value(f, stdout = FALSE)$elapsed
buffered_obliggwdep_within_sg_ring <- value(f, stdout = FALSE)$result
write_sf(buffered_obliggwdep_within_sg_ring, 
         file.path(datapath, 
                   "buffered_obliggwdep_within_sg_ring.gpkg"),
         delete_dsn = TRUE)
```


```{r eval=gpkg_buffered_obliggwdep_within_sg_ring_exists && !params$rewrite_intermediate_files, include=FALSE}
buffered_obliggwdep_within_sg_ring <- 
  read_sf(file.path(datapath, 
                    "buffered_obliggwdep_within_sg_ring.gpkg"))
```

Resulting object: `buffered_obliggwdep_within_sg_ring`.


## Add 200 m buffer around previously created zones to minimize false negatives

```{r include=FALSE}
gpkg_newareas_exists <- 
  file.exists(file.path(datapath, 
                        "new_areas.gpkg"))
```

```{r eval=!gpkg_newareas_exists || params$rewrite_intermediate_files}
buffered_obliggwdep_within_soilanthrop_buff200 <- 
  buffered_obliggwdep_within_soilanthrop %>% 
  st_buffer(200) %>% 
  st_union %>% 
  st_as_sf

narrow_soilanthrop_with_obliggwdep_buff200 <-
  narrow_soilanthrop_with_obliggwdep %>% 
  select(-everything()) %>% 
  st_buffer(200) %>% 
  st_union %>% 
  st_as_sf

buffered_obliggwdep_within_sg_ring_buff200 <- 
  buffered_obliggwdep_within_sg_ring %>% 
  st_buffer(200) %>% 
  st_as_sf

if (gpkg_newareas_exists) unlink(file.path(datapath, "new_areas.gpkg"))

list(buffered_obliggwdep_within_soilanthrop_buff200 =
       buffered_obliggwdep_within_soilanthrop_buff200,
     narrow_soilanthrop_with_obliggwdep_buff200 =
       narrow_soilanthrop_with_obliggwdep_buff200,
     buffered_obliggwdep_within_sg_ring_buff200 =
       buffered_obliggwdep_within_sg_ring_buff200) %>% 
  walk2(names(.),
        ~write_sf(.x,
                  dsn = file.path(datapath, "new_areas.gpkg"),
                  layer = .y))
```

```{r eval=gpkg_newareas_exists && !params$rewrite_intermediate_files, include=FALSE}
walk(1:3, function(i) {
  layername <- st_layers(file.path(datapath, "new_areas.gpkg"))$name[i]
  assign(layername,
         read_sf(file.path(datapath, "new_areas.gpkg"),
                 layer = layername))
})
```

We write the three resulting layers into `new_areas.gpkg`:

```{r paged.print=FALSE}
st_layers(file.path(datapath, "new_areas.gpkg"))
```

Each layer consists of just one Multipolygon.
That is the result of unioning steps (obtained with `st_union()`; corresponding QGIS terminology is `native:aggregate`).
The unioning is done in order to prevent overlapping polygons within the same layer as a consequence of creating buffers.

## Union the new zones (keeping intersections), subtract the original `shallowgroundwater` layer and append

We extend `shallowgroundwater` as described in section \@ref(method).

```{r include=FALSE}
gpkg_sg_extended_exists <- file.exists(file.path(datapath, "sg_extended.gpkg"))
```


```{r eval=params$overwrite_sg_extended || !gpkg_sg_extended_exists, warning=FALSE}
# qgis_arguments("native:union")
# use of future unneeded in this case (runs quickly)
f <- future({
  elapsed <- 
    system.time(
      result <- qgis_run_algorithm("native:union",
                                   INPUT = 
                                     buffered_obliggwdep_within_soilanthrop_buff200 %>% 
                                     mutate(within_soilanthrop_plus_buffer = TRUE),
                                   OVERLAY = 
                                     narrow_soilanthrop_with_obliggwdep_buff200 %>% 
                                     mutate(narrow_soilanthrop_plus_buffer = TRUE))
    )
  list(result = result, elapsed = elapsed)
}, seed = NULL)
# resolved(f)
value(f, stdout = FALSE, signal = FALSE)$elapsed
res_filepath <- value(f, stdout = FALSE)$result$OUTPUT %>% as.character

f <- future({
  elapsed <- 
    system.time(
      result <- qgis_run_algorithm("native:union",
                                   INPUT = 
                                     res_filepath,
                                   OVERLAY = 
                                     buffered_obliggwdep_within_sg_ring_buff200 %>% 
                                     mutate(nearby_originalsg_plus_buffer = TRUE))
    )
  list(result = result, elapsed = elapsed)
}, seed = NULL)
# resolved(f)
value(f, stdout = FALSE, signal = FALSE)$elapsed
res_filepath2 <- value(f, stdout = FALSE)$result$OUTPUT %>% as.character
```

```{r eval=params$overwrite_sg_extended || !gpkg_sg_extended_exists, warning=FALSE}
f <- future({
  elapsed <- 
    system.time(
      result <- 
        read_sf(res_filepath2) %>% 
        select(-starts_with("fid")) %>% 
        mutate(across(where(is.logical), ~ifelse(is.na(.), FALSE, .))) %>% 
        st_difference(
          sg_repairedgeom %>% 
            st_union()
        )
    )
  list(result = result, elapsed = elapsed)
}, seed = NULL)
# resolved(f)
value(f, stdout = FALSE, signal = FALSE)$elapsed
addition <- value(f, stdout = FALSE)$result
```

The result is written as `sg_extended.gpkg`.

```{r eval=params$overwrite_sg_extended || !gpkg_sg_extended_exists}
sg_extended <- 
  sg_repairedgeom %>% 
  as_tibble %>% 
  bind_rows(
    addition %>% as_tibble
  ) %>% 
  st_sf(crs = 31370)
```

Note that the attributes of the original data source need cleaning; `sg_extended` now has `r ncol(sg_extended) - 1` attribute columns.

```{r eval=params$overwrite_sg_extended || !gpkg_sg_extended_exists}
system.time(
write_sf(sg_extended,
         file.path(datapath, "sg_extended.gpkg"),
         delete_dsn = TRUE,
         )
)
```

```{r}
plan(sequential)
```

