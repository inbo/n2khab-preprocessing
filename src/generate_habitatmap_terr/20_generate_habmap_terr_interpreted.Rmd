# Introduction

The standardized version of the habitat map has still some features that need interpretation or clarification. The combined use of code for the habitat main types and sub types can be a problem. Here we do some generally applicable specifications (from main type to sub type). In addition some mapping that are uncertain will be excluded. 

Many analysis require a clear distinction between water and terrestrial biotopes. That's why we want to make a separate map of terrestrial habitat types or RIBs (RBBs) and of aquatic habitat types/RIBs.
The latter is represented by the data source `watersurfaces_hab`.
It combines the currently available information on the presence of watersurfaces and the presence of types, in order to provide the areas where aquatic types will probably or potentially be present.
To that aim, it takes a conservative approach in defining the aquatic areas, meaning that in reality quite some (semi-)terrestrial areas are covered as well! ^[
An analysis of the latter has been made in the notebook `explore_clipping_watsurf_from_habmap.Rmd`:
"Is clipping watersurfaces out of habitatmap_stdized a sensible step in generating a derived data source `habitatmap_terr`?"
]
Likewise, when generating `habitatmap_terr`, we try to only omit polygons of which we are quite sure that they are aquatic!

The consequence of this is that there will be a deliberate overlap between `watersurfaces_hab` and `habitatmap_terr`, which perfectly makes sense.

More details are being discussed in the proceeding chapters.


# Read standardized habitatmap and source habitatmap

## Data sources

Startingpoint for the interpretation is the standardized version of the shapefile of the BWK and Natura 2000 habitat map of Flanders. For more details about the standardized version see [its source location at Zenodo](https://doi.org/10.5281/zenodo.3355192).

### Standardized version

To be sure we will use the correct version of the data source (habitatmap_stdized_2020_v1), we will derive the md5 and sha256 file hashes and compare it to the file hashes in the [data source version overview table](https://docs.google.com/spreadsheets/d/1E8ERlfYwP3OjluL8d7_4rR1W34ka4LRCE35JTxf3WMI/edit#gid=2100595853).

```{r}

path <- fileman_up("n2khab_data")
file <- "20_processed/habitatmap_stdized"

mypath <- file.path(path, file)

hashes <-
    tibble(filepath = str_c(mypath, "/",
        list.files(path = mypath,
            recursive = TRUE)
      )) %>%
    mutate(filename = str_match(filepath, "(.+\\/)*(.+)")[,3],
           md5 = map(filepath, function(x) {
                           file(x) %>% md5 %>% str_c(collapse = '')
                         }) %>% as.character,
           sha256 = map(filepath, function(x) {
                          file(x) %>% sha256 %>% str_c(collapse = '')
                          }) %>% as.character,
           md5_ref = c("ca5724ba6749a77f93bf5167fd02c47c"),
           sha256_ref = c("a466ca91896d5354636e23fff83c9b1df603b1d0f3b0ed45f15ea10af7da0181"),
           match = md5 == md5_ref & sha256 == sha256_ref) %>%
    select(filename,
           md5,
           sha256,
           md5_ref,
           sha256_ref,
           match)

kable(hashes) %>%
  kable_styling()
```


```{r read_processed_data}

# habfile <- "20_processed/habitatmap_stdized/habitatmap_stdized.gpkg"

habmap_stdized <- read_habitatmap_stdized()

habmap_polygons <- habmap_stdized$habitatmap_polygons

# following requires at least n2khab 0.0.3.9037 and 
# data source version habitatmap_stdized_2020:
habmap_types <- habmap_stdized$habitatmap_types 

```

### Source version

In some cases we'll need to refer to the source-map (from [Zenodo](https://zenodo.org/record/4428002#.YBqzu-hKigY)).

Again we wil check if it is the correct version (habitatmap_2020).

```{r}
path <- fileman_up("n2khab_data")
file <- "10_raw/habitatmap"

mypath <- file.path(path, file)

hashes <-
    tibble(filepath = str_c(mypath, "/",
        list.files(path = mypath,
            recursive = TRUE)
      )) %>%
    mutate(filename = str_match(filepath, "(.+\\/)*(.+)")[,3],
           md5 = map(filepath, function(x) {
                           file(x) %>% md5 %>% str_c(collapse = '')
                         }) %>% as.character,
           sha256 = map(filepath, function(x) {
                          file(x) %>% sha256 %>% str_c(collapse = '')
                          }) %>% as.character,
           md5_ref = c("f767a12540b2bde435c6709c9c9675ad",
                      "358ff672c2fae48eba5bd09f8a671675",
                      "f881f61a6c07741b58cb618d8bbb0b99",
                      "1da89a5dc267bbd427c8c07fcf63f344",
                      "79ae8b4b3c6d970a1f10e78f3eca9ef7"),
           sha256_ref = c("c76819ecf3f1276caea9ff8514b4c0f2d201a12e4b13dabd70dd7c42bc05318a",
                         "be029dba3d7ff730407842eee3b43bbec8b2536701ccf7e54c114ba6ee8ac6f4",
                         "a8225ebf83d19412567ce9b909f03631626eec43dffb1f067c7edf3d59ab3aa4",
                         "c457ab6ae5728b4c0da79793a6d328806aeca13234a76b7d41b1cf8c50b78a19",
                         "5f717cd7393869e396ddb174a618bbf615521968fad6af605ed5586d250768cd"),
           match = md5 == md5_ref & sha256 == sha256_ref) %>%
    select(filename,
           md5,
           sha256,
           md5_ref,
           sha256_ref,
           match)

kable(hashes) %>%
  kable_styling()

```


```{r read_raw_data, message=FALSE}
habmap_sf <- read_habitatmap()
```

# Interpretations

## Case rbbhfl

Rbbhfl is a code which needs interpretation from BWK + habitatmap, in order to make it ‘appear’ (these polygons currently appear as rbbhf).

```{r detect rbbhfl}

#filter hfl-types from bwk units
habmap_hfl <- habmap_sf  %>% 
    inner_join(habmap_types, by = c("polygon_id")) %>% 
    mutate(rbbhfl = str_detect(bwk_label, "hfl")) %>% 
    select(polygon_id, bwk_label, rbbhfl, type, code_orig) %>% 
    filter(rbbhfl == TRUE & type == "rbbhf") 

#update habmap_polygons -> habmap_polygons_interpreted
habmap_polygons_interpreted <- habmap_polygons %>% 
    left_join(habmap_hfl %>% 
                  select(polygon_id, rbbhfl) %>% 
                   st_drop_geometry(), by = c("polygon_id")) %>% 
    mutate(description = ifelse(is.na(rbbhfl), description_orig, str_replace_all(description_orig, "rbbhf", "rbbhfl")),
           source = ifelse(is.na(rbbhfl), "habitatmap_stdized", "habitatmap_stdized + interpretation")) %>% 
    select(-rbbhfl)

#update habmap_types -> habmap_types_interpreted
habmap_types_interpreted <- habmap_types %>% 
    left_join(habmap_hfl %>% 
                  select(polygon_id, rbbhfl) %>% 
                   st_drop_geometry(), by = c("polygon_id")) %>% 
    mutate(type = ifelse(is.na(rbbhfl) | type != "rbbhf", as.character(type), str_replace_all(type, "rbbhf", "rbbhfl")),
           source = ifelse(is.na(rbbhfl) | type != "rbbhfl", "habitatmap_stdized", "habitatmap_stdized + interpretation")) %>% 
    select(-rbbhfl) 

```

## Case 2190

Considering code 2190 in the habitatmap, this code refers to the sum of 2190_a and 2190_overig. It is necessary to use BWK fields from the raw habitatmap data source in order to distinguish 2190_a.
As the `watersurfaces_hab` data source also covers (semi-)terrestrial areas (see introduction), it is not such a good idea to start from that data source.^[
Note that also some topological difficulties arise in intersecting the habitatmap and the watersurfaces-map, encountered in the notebook 
`explore_clipping_watsurf_from_habmap.Rmd`:
"Is clipping watersurfaces out of habitatmap_stdized a sensible step in generating a derived data source `habitatmap_terr`?".
Both the habitatmap and the watersurfaces layer contain polygons which topological faults.
This was solved by using GRASS from R.
This geospatial processing software makes the necessary corrections to the layers when importing them.
]

It's possible that a watersurface is being mapped together with other biotopes. The first unit of a complex is most probable predominant. Only if the first unit is a watersurface than 2190 will be interpreted as 2190_a, otherwise 2190_overig.

```{r detect dune water}
habmap_dunewater <- habmap_sf %>% 
    inner_join(habmap_types_interpreted, by = c("polygon_id")) %>% 
    mutate(dunewater = str_detect(eenh1, c("ae|kn"))) %>% 
    select(polygon_id, bwk_label, dunewater, type, code_orig) %>% 
    filter(dunewater == TRUE & type == "2190") 

#update habmap_polygons -> habmap_polygons_interpreted
habmap_polygons_interpreted <- habmap_polygons_interpreted %>% 
    left_join(habmap_dunewater %>% 
                  select(polygon_id, dunewater) %>% 
                   st_drop_geometry(), by = c("polygon_id")) %>% 
    mutate(description = ifelse(is.na(dunewater),
                                str_replace_all(description, "2190_","2191_"),
                                description_orig)) %>% 
    mutate(description = ifelse(is.na(dunewater), 
                                str_replace_all(description, "2190", "2190_overig"),
                                str_replace_all(description, "2190", "2190_a")),
           source = ifelse(str_detect(description, "2190") | source == "habitatmap_stdized + interpretation",
                           "habitatmap_stdized + interpretation", 
                           "habitatmap_stdized")) %>% 
    mutate(description = str_replace_all(description, "2191", "2190")) %>% 
    select(-dunewater)

#update habmap_types -> habmap_types_interpreted
habmap_types_interpreted <- habmap_types_interpreted %>% 
    left_join(habmap_dunewater %>% 
                  select(polygon_id, dunewater) %>% 
                   st_drop_geometry(), by = c("polygon_id")) %>% 
    mutate(type = str_replace_all(type, "2190_", "2191_")) %>% # mark mappings on subtype-level
    mutate(type = case_when(
                    is.na(dunewater) & str_detect(type, "2190") ~ "2190_overig", 
                    is.na(dunewater) ~ as.character(type),                    
                    TRUE ~ "2190_a"
                    ),
           source = case_when(
                    is.na(dunewater) & str_detect(type, "2190") ~ "habitatmap_stdized + interpretation", 
                    is.na(dunewater) ~ source,                    
                    TRUE ~ "habitatmap_stdized + interpretation"
                    ) 
           ) %>% 
    mutate(type = str_replace_all(type, "2191_", "2190_")) %>% 
    select(-dunewater) 


```

## Exclude uncertain mapping that is most likely not a habitat or rbb

For some main types, the main type code mostly refers to a specific subtype – so that code can be used instead when interpreting the habitatmap_stdized data source.
Some mapping units are uncertain, but will only very rarely be habitat type or rbb.
This applies to the following cases:

* code_orig containing 'bos'
* code_orig is 6510,gh or 9120,gh

```{r exclude some uncertain mapping units}
habmap_types_interpreted <- 
    habmap_types_interpreted %>%
    filter(!str_detect(code_orig, "bos") & !(code_orig %in% c("6510,gh", "9120,gh")))
habmap_polygons_interpreted <- 
    habmap_polygons_interpreted %>%
    semi_join(habmap_types_interpreted, by = "polygon_id")
```

## Exclude water surfaces

This interpreted version of the habitat map contains only terrestrial biotopes. The interpreted water surfaces are returned by `read_watersurfaces_hab(interpreted = TRUE)`.
The standardized habitatmap contains also watersurfaces (streaming water are much less mapped). They have therefore to be excluded from the interpreted terrestrial version.
By using habitatmap_stdized we actually can never be sure about 'pure' water, because types were already dropped from non-dropped polygons before:

* in generating habitatmap_stdized, only rows where `code_orig` contains a habitat or RIB code have been retained, others were dropped (such as gh, x and bos) ;
* rows where `code_orig` contains "bos" or is one of "6510,gh", "9120,gh" were already omitted.

It means we will actually drop polygons which, besides water types, _contain no other habitat or rib_. And that still matches our aim, i.e. terrestrial habitats / rib

```{r exclude water surfaces}
watertypes <- data.frame( "watertype" = c("1130", "2190_a", "3110", "3130", "3130_aom", "3130_na", "3140", "3150", "3160", "3260", "7220", "rbbah"))

#polygons that are, regarding their habitat/rib content, exclusively represented by water type(s) are excluded.
# polygons with only a very small portion of habitat/rib terrestrial and almost entirely watersurface ars still included.
# fyi: polygons with a very small portion of watersurface that for the remaining part are terrestrial non(!)-habitat/rib are excluded

habmap_polygons_water <- 
    habmap_types_interpreted %>% 
    group_by(polygon_id) %>% 
    mutate(oppsum = sum(phab)) %>% 
    semi_join(watertypes, by = c("type" = "watertype")) %>% 
    group_by(polygon_id, oppsum) %>% 
    summarise(opp = sum(phab)) %>% 
    ungroup() %>% 
    filter(opp == oppsum)

habmap_polygons_interpreted <- habmap_polygons_interpreted %>% 
    anti_join(habmap_polygons_water)

habmap_types_interpreted <- habmap_types_interpreted %>% 
    anti_join(habmap_polygons_water)    


```

## Cases with common subtypes

For some main types, the main type code mostly refers to a specific subtype – so that code can be used instead when interpreting the habitatmap_stdized data source.

For the terrestrial types it's about the following types

|Main type|Most probable subtype|
|:---------:|:---------------------:|
|6410|6410_mo|
|6430|6430_hf|
|6510|6510_hu|
|7140|7140_meso|
|9130|9130_end|

```{r common subtypes}
habmap_polygons_interpreted <- habmap_polygons_interpreted %>% 
    mutate( description = str_replace_all(description, c("6410_" = "641µ_",
                                                        "6430_" = "643µ_",
                                                        "6510_" = "651µ_",
                                                        "7140_" = "714µ_",
                                                        "9130_" = "913µ_"))) %>% 
    mutate(
        description = str_replace_all(description, c("6410" = "6410_mo",
                                                        "6430" = "6430_hf",
                                                        "6510" = "6510_hu",
                                                        "7140" = "7140_meso",
                                                        "9130" = "9130_end")),
        source = case_when(
            str_detect(description, "6410") ~ "habitatmap_stdized + interpretation",
            str_detect(description, "6430") ~ "habitatmap_stdized + interpretation",
            str_detect(description, "6510") ~ "habitatmap_stdized + interpretation",
            str_detect(description, "7140") ~ "habitatmap_stdized + interpretation",
            str_detect(description, "9130") ~ "habitatmap_stdized + interpretation",
            TRUE ~ source
            )
        ) %>% 
    mutate( description = str_replace_all(description, "µ_", "0_")) %>% 
    mutate( source =  as.factor(source))

habmap_types_interpreted <- habmap_types_interpreted %>% 
    mutate(type = str_replace_all(type, c("6410_" = "641µ_",
                                                        "6430_" = "643µ_",
                                                        "6510_" = "651µ_",
                                                        "7140_" = "714µ_",
                                                        "9130_" = "913µ_"))) %>% 
    mutate(
        type = str_replace_all(type, c("6410" = "6410_mo",
                                                        "6430" = "6430_hf",
                                                        "6510" = "6510_hu",
                                                        "7140" = "7140_meso",
                                                        "9130" = "9130_end")),
        source = case_when(
            str_detect(type, "6410") ~ "habitatmap_stdized + interpretation",
            str_detect(type, "6430") ~ "habitatmap_stdized + interpretation",
            str_detect(type, "6510") ~ "habitatmap_stdized + interpretation",
            str_detect(type, "7140") ~ "habitatmap_stdized + interpretation",
            str_detect(type, "9130") ~ "habitatmap_stdized + interpretation",
            TRUE ~ source
            )
        ) %>% 
    mutate( type = str_replace_all(type, "µ_", "0_")) %>% 
    mutate( type = as.factor(type),
            source =  as.factor(source))
```

## Write results into a geopackage

```{r}
dir.create(file.path(path, "20_processed/habitatmap_terr"), recursive = TRUE)
```

```{r}
st_write(habmap_polygons_interpreted,
         file.path(path, 
                   "20_processed/habitatmap_terr/habitatmap_terr.gpkg"), 
         layer = "habitatmap_terr_polygons", 
         driver = "GPKG",
         delete_dsn = TRUE)

st_write(habmap_types_interpreted,
         file.path(path, 
                   "20_processed/habitatmap_terr/habitatmap_terr.gpkg"),
         layer = "habitatmap_terr_types", 
         driver = "GPKG",
         append = TRUE)

```
