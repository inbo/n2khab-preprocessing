# Generate standardized habitatmap

## Data source

The shapefile of the BWK and Natura 2000 habitat map of Flanders can be downloaded [here](https://zenodo.org/record/4428002#.YBqzu-hKigY).

To be sure we will use the correct version of the data source (habitatmap_2020), we will derive the md5 file hashes and compare it to the file hashes in the [data source version overview table](https://docs.google.com/spreadsheets/d/1E8ERlfYwP3OjluL8d7_4rR1W34ka4LRCE35JTxf3WMI/edit#gid=2100595853).

```{r}

path <- fileman_up("n2khab_data")
file <- "10_raw/habitatmap"

mypath <- file.path(path, file)

hashes <-
    tibble(filepath = str_c(mypath, "/",
        list.files(path = mypath,
            recursive = TRUE)
      )) %>%
    mutate(filename = str_match(filepath, "(.+\\/)*(.+)")[,3],
           md5 = map(filepath, function(x) {
                           file(x) %>% md5 %>% str_c(collapse = '')
                         }) %>% as.character,
           md5_ref = c("f767a12540b2bde435c6709c9c9675ad",
                      "358ff672c2fae48eba5bd09f8a671675",
                      "f881f61a6c07741b58cb618d8bbb0b99",
                      "1da89a5dc267bbd427c8c07fcf63f344",
                      "79ae8b4b3c6d970a1f10e78f3eca9ef7"),
           match = md5 == md5_ref) %>%
    select(filename,
           md5,
           md5_ref,
           match)

kable(hashes) %>%
  kable_styling()

if (!all.equal(hashes$md5, hashes$md5_ref)) {
    stop(cat("The source map is NOT up to date ! Please check  the datasource. "))
}
```


```{r read_raw_data}

habitatmap_sf <- st_read(file.path(path, file),
                  layer = "habitatmap")
```



## Processing of the attribute table

Every polygon in the habitat map can consist of maximum 5 different vegetation types. This information is stored in the columns 'HAB1', 'HAB2',..., 'HAB5' of the attribute table. The estimated fraction of each vegetation type within the polygons is stored in the columns 'PHAB1', 'PHAB2', ..., 'PHAB5'.

We will convert the attribute table to a long format, so that every row contains one vegetation type.


```{r select_polygons}

habmap_sf <- habitatmap_sf %>%
            filter(!(HAB1 == "gh" & PHAB1 == 100)) %>%
            mutate(polygon_id = TAG, # unieke id
                   description_orig = str_c(PHAB1, "% ", HAB1,
                                      ifelse(is.na(HAB2), "", str_c("; ", PHAB2, "% ", HAB2)),
                                      ifelse(is.na(HAB3), "", str_c("; ", PHAB3, "% ", HAB3)),
                                      ifelse(is.na(HAB4), "", str_c("; ", PHAB4, "% ", HAB4)),
                                      ifelse(is.na(HAB5), "", str_c("; ", PHAB5, "% ", HAB5)))) 

```


```{r long_format}

habmap_longPHAB <- habmap_sf %>%
    st_drop_geometry() %>%
    gather(PHAB1, PHAB2, PHAB3, PHAB4, PHAB5, key = "phabn", value = "phab") %>%
    mutate(patch_id = str_sub(phabn, 5, 5)) %>%
    select(polygon_id, patch_id, phab) %>%
    filter(!is.na(phab))

habmap_longHAB <- habmap_sf %>%
    st_drop_geometry() %>%
    select(polygon_id, polygon_area = OPPERVL, starts_with("HAB"), -HABLEGENDE) %>%
    gather(HAB1, HAB2, HAB3, HAB4, HAB5, key = "hab", value = "code") %>%
    mutate(patch_id = substr(hab, 4, 4)) %>%
    filter(!is.na(code)) %>%
    filter(! code %in% c("gh", "x"))

```

## Correction of some of the codes in the Habitat map

For some polygons in the habitat map the vegetation type is not certain. When 
this is the case, the code contains the possible vegetation types separated with
a ','. However, in some cases this way of coding is not used. In that case we
change the code according to the general coding rules (for example 3130_rbbmr is
changed to 3130,rbbmr). This makes processing of the habitat map more 
straightforward. Table \@ref(tab:codeCorrected) shows the corrected codes and the number of polygons for which the correction is applied.


```{r }

habmap_correction <- read_vc("habmap_correction/habmap_correction")

overview_habmap_correction <- habmap_longHAB %>%
  inner_join(habmap_correction, by = "code") %>%
  group_by(code, code_corrected) %>%
  summarise(n_polygons = n()) %>%
  ungroup()

```


```{r codeCorrected}
overview_habmap_correction %>%
  kable(caption = "Corrected codes in habitat map") %>%
  kable_styling()
```

```{r}
if(sum(habmap_correction$code %in% habmap_longHAB$code) > 0){

    habmap_longHAB <- habmap_longHAB %>%
        left_join(habmap_correction, by = "code") %>%
        mutate(code_orig = code,
            code = ifelse(is.na(code_corrected),
                             code,
                             code_corrected)) %>%
        select(-code_corrected)
    
    } else {
      
      habmap_longHAB <- habmap_longHAB %>%
        mutate(code_orig = code)
}
```


## Splitting uncertain types

When the vegetation type is uncertain, and 2 or 3 possible vegetation types are provided, separated with a ','. 
We will split the different possible vegetation types and create one row for each of them. 
An additional variable 'certain' will be FALSE if the orginal habitatmap code consists of 2 or 3 possible vegetation types, and TRUE if only one vegetation type is provided.

```{r}

habmap_long <- habmap_longHAB %>%
    left_join(habmap_longPHAB, by = c("polygon_id", "patch_id")) %>%
    mutate(certain = !str_detect(code, ",")) %>%
    separate(code,
             into = c("type1", "type2", "type3"),
             sep = ",",
             remove = FALSE) %>%
    gather(type1, type2, type3, key = "ntype", value = "type") %>%
    filter(!is.na(type)) %>%
    filter(!(type %in% c("gh", "bos"))) %>%
    select(-patch_id)

```



In some cases you get two records for the same type, one certain and one uncertain, within the same habitatmap polygon. 
See for example the case below where you get two phab values for type 3150 within the same polygon. 
Furthermore the sum of the phab values within the polygon is higher than 100. 
Therefore we will distribute the phab value for uncertain types equally over the two possible types (in this case phab = 20 for type 3150 and phab = 20 for type rbbmr). 
Next we sum the phab values over the types within the same polygon. 

```{r}
habmap_long %>%
  filter(polygon_id == "357179_v2020")
```


```{r}
habmap_long <- habmap_long %>%
  group_by(polygon_id, code) %>%
      mutate(n = n()) %>%
    ungroup() %>%
    group_by(polygon_id, type) %>%
     summarise(phab = sum(phab/n),
              code_orig = str_c(code, collapse = "; "),
              certain = all(certain)) %>%
    ungroup() 
```
In this example we will get phab = 80 for 3150 and phab 20 for rbbmr as can be seen below. 

```{r}
habmap_long %>%
  filter(polygon_id == "357179_v2020")
```



## Select vegetation types that belong to the standard list of habitat and rbb types  

Table \@ref(tab:selectTypes) shows the records with habitat types that do not belong to the standard list of habitat and rbb types. These records are filtered out. 

```{r selectTypes}

types <- read_types() %>%
  select(type, typelevel, main_type, typeclass)

habmap_long <- habmap_long %>%
  left_join(types, by = "type")

habmap_types <- habmap_long %>%
  filter(!is.na(typelevel)) %>%
   select(polygon_id, code_orig, phab, certain, type) %>%
  mutate(type = factor(type,
                       levels = levels(types$type)
                       )
         ) %>%
  arrange(polygon_id, desc(phab))
  
habmap_other_type <- habmap_long %>%
  filter(is.na(typelevel))

habmap_other_type %>%
  select(polygon_id, code_orig, phab, certain, type) %>%
  kable(caption = "Polygons with types that do not coorspond with the standard list of types and rbb") %>%
  kable_styling()

```


## Select features that contain habitat or rbb types

```{r}

habmap_types_sf <- habmap_sf %>%
  select(polygon_id, description_orig) %>%
  filter(polygon_id %in% habmap_types$polygon_id)

```

## Write results into a geopackage

```{r}

st_write(habmap_types_sf, file.path(path,"20_processed/habitatmap_stdized/habitatmap_stdized.gpkg"), layer = "habitatmap_polygons", driver = "GPKG", delete_dsn = TRUE)

st_write(habmap_types, file.path(path,"20_processed/habitatmap_stdized/habitatmap_stdized.gpkg"), layer = "habitatmap_types", driver = "GPKG", append = TRUE)

```
